<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TCG Market Simulator</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
html, body {
  margin: 0;
  padding: 0;
  min-height: 100%;
  background: linear-gradient(135deg, #111827 0%, #2e1065 50%, #111827 100%);
}
#root { min-height: 100%; }


    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      overflow-x: hidden;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .card-flip {
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }
    .card-flip.flipped {
      transform: rotateY(180deg);
    }
    .card-face {
      backface-visibility: hidden;
      position: absolute;
      inset: 0;
    }
    .card-back {
      transform: rotateY(180deg);
    }
    .card-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      margin-bottom: 8px;
      z-index: 100;
    }
    .card-wrapper:hover .card-tooltip {
      opacity: 1;
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      cursor: pointer;
      animation: fadeIn 0.2s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .modal-image {
      max-width: 90vw;
      max-height: 90vh;
      border-radius: 12px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      animation: zoomIn 0.2s;
    }
    @keyframes zoomIn {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
  

/* ---- Holo / Foil visuals ---- */
@keyframes holoSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes holoShimmer {
  0% { opacity: 0.10; transform: translateX(-20%) skewX(-10deg); }
  50% { opacity: 0.25; transform: translateX(20%) skewX(-10deg); }
  100% { opacity: 0.10; transform: translateX(-20%) skewX(-10deg); }
}

.foil-glow {
  position: relative;
}

/* Holo overlay applies to the revealed face that shows the card art */
.foil-glow .card-face.card-back {
  /* Keep absolute positioning so flipping doesn't shift layout */
  position: absolute;
  inset: 0;
  overflow: hidden;
  isolation: isolate;
}


.foil-glow .card-face.card-back img {
  position: relative;
  z-index: 1;
  filter: saturate(1.08) contrast(1.04);
}


/* Static, slightly-opaque rainbow filter to make the card itself look holographic */
.foil-glow .card-face.card-back::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  background: linear-gradient(120deg,
    rgba(255, 0, 128, 0.32),
    rgba(0, 255, 255, 0.30),
    rgba(255, 255, 0, 0.28),
    rgba(255, 0, 128, 0.30)
  );
  opacity: 0.42;
  filter: saturate(1.5) contrast(1.08);
  pointer-events: none;
  z-index: 3;
}

/* Subtle highlight to sell the holo effect without animation */
.foil-glow .card-face.card-back::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.22), rgba(255,255,255,0.0) 55%);
  opacity: 0.20;
  pointer-events: none;
  z-index: 4;
}

.holo-badge {
  background: linear-gradient(90deg,
    rgba(255, 0, 128, 0.40),
    rgba(0, 255, 255, 0.40),
    rgba(255, 255, 0, 0.40)
  );
  box-shadow: 0 0 18px rgba(255,255,255,0.15);
  color: rgba(255,255,255,0.98);
  text-shadow: 0 1px 2px rgba(0,0,0,0.85);
}

.rainbow-text {
  background: linear-gradient(90deg, #ff3ea5, #2ee9ff, #ffe155, #ff3ea5);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  filter: drop-shadow(0 0 10px rgba(255,255,255,0.20));
}

.holo-button {
  background: linear-gradient(90deg, #ff3ea5, #2ee9ff, #ffe155, #ff3ea5);
  box-shadow: 0 0 18px rgba(255,255,255,0.18);
}

/* ===== God Pack effect ===== */
@keyframes godGlowPulse {
  0% { opacity: 0; transform: scale(0.95); }
  20% { opacity: 1; transform: scale(1.0); }
  100% { opacity: 0; transform: scale(1.05); }
}
@keyframes confettiFall {
  0% { transform: translateY(-20vh) rotate(0deg); opacity: 1; }
  100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
}
.godpack-effect {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 2500;
  overflow: hidden;
}
.godpack-effect::before {
  content: '';
  position: absolute;
  inset: -20%;
  background: radial-gradient(circle at 50% 40%, rgba(255,255,255,0.28), rgba(168,85,247,0.12) 40%, rgba(0,0,0,0) 72%);
  mix-blend-mode: screen;
  animation: godGlowPulse 1.6s ease-out forwards;
}
.confetti-piece {
  position: absolute;
  top: -12vh;
  width: var(--w);
  height: var(--h);
  left: var(--left);
  background: var(--c);
  border-radius: 2px;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.35));
  animation: confettiFall var(--dur) linear forwards;
  animation-delay: var(--delay);
  opacity: 0.95;
}
.godpack-gate {
  position: fixed;
  inset: 0;
  z-index: 3200;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.72);
  backdrop-filter: blur(6px);
}
.godpack-gate-card {
  width: min(560px, 92vw);
  border-radius: 18px;
  padding: 24px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(17,24,39,0.92);
  box-shadow: 0 30px 90px rgba(0,0,0,0.55);
  position: relative;
  overflow: hidden;
}
.godpack-gate-card::before {
  content: '';
  position: absolute;
  inset: -30%;
  background: conic-gradient(from 90deg, rgba(168,85,247,0.35), rgba(34,211,238,0.28), rgba(250,204,21,0.28), rgba(244,63,94,0.26), rgba(168,85,247,0.35));
  filter: blur(20px);
  opacity: 0.85;
}
.godpack-gate-content {
  position: relative;
  text-align: center;
}
.godpack-gate-title {
  font-size: 34px;
  font-weight: 900;
  letter-spacing: 1px;
  text-transform: uppercase;
  margin: 0 0 8px 0;
}
.godpack-gate-sub {
  color: rgba(255,255,255,0.85);
  margin: 0 0 18px 0;
  line-height: 1.35;
}
.godpack-gate-note {
  color: rgba(255,255,255,0.70);
  margin: 0 0 18px 0;
  font-size: 13px;
}
.godpack-gate-actions {
  display: flex;
  justify-content: center;
  gap: 10px;
}
.godpack-banner {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.20);
  background: radial-gradient(circle at 30% 30%, rgba(236,72,153,0.25), rgba(168,85,247,0.15), rgba(0,0,0,0.25));
  box-shadow: 0 0 40px rgba(236,72,153,0.20), 0 0 60px rgba(168,85,247,0.18);
}



/* ===== Mobile Navigation ===== */
.hamburger-btn { display: none; }
.menu-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  z-index: 200;
}
.menu-panel {
  position: fixed;
  top: 66px;
  right: 12px;
  width: min(340px, calc(100vw - 24px));
  background: rgba(17,24,39,0.96);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 16px;
  padding: 10px;
  z-index: 201;
  box-shadow: 0 24px 70px rgba(0,0,0,0.55);
  backdrop-filter: blur(10px);
}
@media (max-width: 720px) {
  .topbar-nav { display: none !important; }
  .hamburger-btn { display: inline-flex !important; align-items: center; justify-content: center; }
  .topbar-title { font-size: 18px !important; }
  .topbar { padding: 10px 12px !important; }
}


/* ===== Mobile UX improvements (v14) ===== */
:root{
  --ui-radius: 16px;
  --ui-radius-sm: 12px;
  --ui-pad: 12px;
  --ui-pad-sm: 10px;
  --ui-border: 1px solid rgba(255,255,255,0.12);
}

button, [role="button"]{
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

.topbar{
  position: sticky;
  top: 0;
  z-index: 220;
  backdrop-filter: blur(10px);
}

/* Make sure the page never shows white on iOS when rubber-banding */
body{
  background-color: #111827;
  overscroll-behavior-y: none;
}

@keyframes menuSlideUp{
  from{ transform: translateY(14px); opacity: 0.0; }
  to{ transform: translateY(0); opacity: 1; }
}

@media (max-width: 720px){
  /* Respect iOS safe areas */
  .topbar{
    padding-top: calc(10px + env(safe-area-inset-top)) !important;
    padding-left: calc(12px + env(safe-area-inset-left)) !important;
    padding-right: calc(12px + env(safe-area-inset-right)) !important;
  }

  



  .menu-item{
    padding: 14px 14px !important;
    font-size: 16px !important;
    border-radius: 14px !important;
  }

  /* Bigger taps across the app */
  .hamburger-btn{
    width: 42px !important;
    height: 42px !important;
    border-radius: 12px !important;
  }

  /* Modal images slightly larger and less cramped */
  .modal-image{
    max-width: 94vw !important;
    max-height: 86vh !important;
  }
}

/* Improve readability on small screens (badges, small overlays) */
.card-dup-badge, .holo-dup-badge{
  text-shadow: 0 1px 2px rgba(0,0,0,0.65);
}

/* ===== Pack Ripping Styles ===== */
.pack-rip-container {
  position: relative;
  width: 280px;
  height: 400px;
  margin: 0 auto;
  perspective: 1000px;
}

.pack-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
}

.pack-body {
  position: absolute;
  inset: 0;
  border-radius: 16px;
  overflow: hidden;
  border: 3px solid rgba(168, 85, 247, 0.5);
  box-shadow: 0 25px 50px -12px rgba(168, 85, 247, 0.5);
}

.pack-top {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  background: linear-gradient(180deg, rgba(168, 85, 247, 0.8) 0%, rgba(168, 85, 247, 0.4) 100%);
  border-bottom: 3px dashed rgba(255, 255, 255, 0.4);
  cursor: grab;
  z-index: 10;
  transform-origin: left center;
  transition: transform 0.1s ease-out;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pack-top:active {
  cursor: grabbing;
}

.pack-top-text {
  color: white;
  font-size: 12px;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
  pointer-events: none;
  opacity: 0.9;
}

.pack-tear-progress {
  position: absolute;
  top: 57px;
  left: 0;
  height: 6px;
  background: linear-gradient(90deg, #ec4899, #a855f7);
  border-radius: 0 3px 3px 0;
  transition: width 0.05s linear;
  box-shadow: 0 0 10px rgba(236, 72, 153, 0.5);
}

@keyframes packTopTearOff {
  0% { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(-100px) rotate(-15deg); opacity: 0; }
}

.pack-top-torn {
  animation: packTopTearOff 0.4s ease-out forwards;
}

/* Card stack styles */
.card-stack-container {
  position: relative;
  width: 220px;
  height: 308px;
  margin: 0 auto;
}

.stacked-card {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 12px;
  overflow: hidden;
  transition: transform 0.3s ease-out, opacity 0.3s ease-out;
  cursor: pointer;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.stacked-card img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

@keyframes cardSlideOff {
  0% { transform: translateX(0) rotate(0deg); opacity: 1; }
  100% { transform: translateX(400px) rotate(15deg); opacity: 0; }
}

.card-sliding-off {
  animation: cardSlideOff 0.35s ease-in forwards;
  pointer-events: none;
}

/* Grid reveal layout */
.cards-grid-reveal {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 12px;
  max-width: 700px;
  margin: 0 auto;
}

.cards-grid-reveal .grid-card {
  aspect-ratio: 2.5/3.5;
  border-radius: 10px;
  overflow: hidden;
  transition: transform 0.2s, box-shadow 0.2s;
  cursor: pointer;
  position: relative;
}

.cards-grid-reveal .grid-card:hover {
  transform: scale(1.05);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
}

.cards-grid-reveal .grid-card img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

</style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;

    // Since this is on GitHub Pages, use relative paths to images in the same repo
    const GITHUB_BASE = '.';

    // ===== CONFIG LOADING =====
    const fetchJson = async (path) => {
      const res = await fetch(`${GITHUB_BASE}/${path}`);
      if (!res.ok) throw new Error(`Failed to load ${path}`);
      return res.json();
    };

    // Helper to build image URL from config
    const buildImageUrl = (gameId, setId, card) => {
      const folder = card.rarity.replace(/ /g, '%20');
      const filename = card.file.replace(/ /g, '%20');
      return `${GITHUB_BASE}/games/${gameId}/${setId}/${folder}/${filename}`;
    };

    // Helper to build cardback URL
    const buildCardbackUrl = (gameConfig) => {
      return `${GITHUB_BASE}/${gameConfig.cardback}`;
    };

    // Helper to build product image URL
    const buildProductImageUrl = (gameId, setId, productType) => {
      // Map product types to image filenames
      const filename = productType === 'single' ? 'pack.png' : `${productType}.png`;
      return `${GITHUB_BASE}/games/${gameId}/${setId}/products/${filename}`;
    };

    // Build RARITY_COLORS from game config
    const buildRarityColors = (gameConfig) => {
      const colors = {};
      gameConfig.rarities.forEach(r => {
        colors[r.id] = {
          bg: r.bgColor,
          border: r.borderColor,
          text: r.color,
          isRainbow: r.isRainbow || false
        };
      });
      return colors;
    };

    // Build CARDS_BY_RARITY from set config
    const buildCardsByRarity = (setConfig, rarityOrder) => {
      const byRarity = {};
      rarityOrder.forEach(r => {
        byRarity[r] = setConfig.cards.filter(c => c.rarity === r);
      });
      return byRarity;
    };

    // ===== MAIN APP WRAPPER =====
    function App() {
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [gamesIndex, setGamesIndex] = useState(null);
      const [gameConfigs, setGameConfigs] = useState({});
      const [setConfigs, setSetConfigs] = useState({});
      
      // Current selection
      const [currentGameId, setCurrentGameId] = useState(null);
      const [currentSetId, setCurrentSetId] = useState(null);

      // Load all configs on mount
      useEffect(() => {
        const loadConfigs = async () => {
          try {
            // Load main index
            const index = await fetchJson('games/index.json');
            setGamesIndex(index);

            // Load all game configs
            const gameConfigsMap = {};
            const setConfigsMap = {};

            for (const game of index.games) {
              if (!game.enabled) continue;
              
              const gameConfig = await fetchJson(game.configPath);
              gameConfigsMap[game.id] = gameConfig;
              setConfigsMap[game.id] = {};

              // Load all sets for this game
              for (const setId of gameConfig.sets) {
                const setPath = `games/${game.id}/${setId}/set.json`;
                const setConfig = await fetchJson(setPath);
                setConfigsMap[game.id][setId] = setConfig;
              }
            }

            setGameConfigs(gameConfigsMap);
            setSetConfigs(setConfigsMap);

            // Set default game/set from localStorage or index default
            const savedGame = localStorage.getItem('tcg-current-game');
            const savedSet = localStorage.getItem('tcg-current-set');
            
            const defaultGameId = savedGame && gameConfigsMap[savedGame] ? savedGame : index.defaultGame;
            setCurrentGameId(defaultGameId);
            
            const defaultSetId = savedSet && setConfigsMap[defaultGameId]?.[savedSet] 
              ? savedSet 
              : gameConfigsMap[defaultGameId]?.sets[0];
            setCurrentSetId(defaultSetId);

            setLoading(false);
          } catch (err) {
            console.error('Failed to load configs:', err);
            setError(err.message);
            setLoading(false);
          }
        };

        loadConfigs();
      }, []);

      // Save current game/set selection
      useEffect(() => {
        if (currentGameId) localStorage.setItem('tcg-current-game', currentGameId);
      }, [currentGameId]);

      useEffect(() => {
        if (currentSetId) localStorage.setItem('tcg-current-set', currentSetId);
      }, [currentSetId]);

      // Switch game handler
      const switchGame = useCallback((gameId) => {
        if (!gameConfigs[gameId]) return;
        setCurrentGameId(gameId);
        // Reset to first set of new game
        const firstSet = gameConfigs[gameId].sets[0];
        setCurrentSetId(firstSet);
      }, [gameConfigs]);

      // Switch set handler  
      const switchSet = useCallback((setId) => {
        if (!setConfigs[currentGameId]?.[setId]) return;
        setCurrentSetId(setId);
      }, [currentGameId, setConfigs]);

      if (loading) {
        return (
          <div style={{ 
            minHeight: '100vh', 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center',
            flexDirection: 'column',
            gap: 16,
            color: 'white'
          }}>
            <div style={{ 
              width: 48, 
              height: 48, 
              border: '4px solid rgba(255,255,255,0.2)', 
              borderTopColor: '#a855f7',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite'
            }} />
            <div>Loading game data...</div>
          </div>
        );
      }

      if (error) {
        return (
          <div style={{ 
            minHeight: '100vh', 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center',
            flexDirection: 'column',
            gap: 16,
            color: 'white',
            padding: 32
          }}>
            <div style={{ fontSize: 24, fontWeight: 'bold', color: '#f87171' }}>Failed to Load</div>
            <div style={{ color: '#9ca3af', textAlign: 'center' }}>{error}</div>
            <button 
              onClick={() => window.location.reload()}
              style={{
                padding: '12px 24px',
                background: '#9333ea',
                color: 'white',
                border: 'none',
                borderRadius: 8,
                cursor: 'pointer',
                marginTop: 16
              }}
            >
              Retry
            </button>
          </div>
        );
      }

      const currentGameConfig = gameConfigs[currentGameId];
      const currentSetConfig = setConfigs[currentGameId]?.[currentSetId];

      if (!currentGameConfig || !currentSetConfig) {
        return <div style={{ color: 'white', padding: 32 }}>No game data available</div>;
      }

      return (
        <TCGPackOpener
          gamesIndex={gamesIndex}
          gameConfigs={gameConfigs}
          setConfigs={setConfigs}
          currentGameId={currentGameId}
          currentSetId={currentSetId}
          currentGameConfig={currentGameConfig}
          currentSetConfig={currentSetConfig}
          switchGame={switchGame}
          switchSet={switchSet}
        />
      );
    }

    // ===== MAIN GAME COMPONENT =====
    function TCGPackOpener({ 
      gamesIndex, 
      gameConfigs, 
      setConfigs, 
      currentGameId, 
      currentSetId,
      currentGameConfig,
      currentSetConfig,
      switchGame,
      switchSet
    }) {
      // Derived values from config
      const ALL_CARDS = currentSetConfig.cards;
      const RARITY_ORDER = currentGameConfig.rarityOrder;
      const RARITY_COLORS = useMemo(() => buildRarityColors(currentGameConfig), [currentGameConfig]);
      const CARDS_BY_RARITY = useMemo(() => buildCardsByRarity(currentSetConfig, RARITY_ORDER), [currentSetConfig, RARITY_ORDER]);
      
      const getImageUrl = useCallback((card) => {
        return buildImageUrl(currentGameId, currentSetId, card);
      }, [currentGameId, currentSetId]);

      const getCardbackUrl = useCallback(() => {
        // Use opening pack's game config if available, otherwise current
        const gameId = openingPackGameId || currentGameId;
        const gameConfig = gameConfigs[gameId] || currentGameConfig;
        return buildCardbackUrl(gameConfig);
      }, [currentGameConfig, openingPackGameId, currentGameId, gameConfigs]);

      // Get the pack image URL for the currently opening pack (computed directly, not memoized)
      const openingPackImageUrl = openingPackGameId && openingPackSetId 
        ? buildProductImageUrl(openingPackGameId, openingPackSetId, 'single')
        : buildProductImageUrl(currentGameId, currentSetId, 'single');
      
      const openingCardbackUrl = openingPackGameId 
        ? buildCardbackUrl(gameConfigs[openingPackGameId] || currentGameConfig)
        : buildCardbackUrl(currentGameConfig);

      // Helper to get sealed product info from config
      const getSealedInfo = useCallback((type) => {
        const config = currentSetConfig.sealedProducts?.[type];
        const packSize = currentSetConfig.packStructure?.size || 8;
        const packs = config?.packs || (type === 'bundle' ? 8 : type === 'booster' ? 24 : 144);
        const cards = packs * packSize;
        const guaranteed = config?.guaranteed || [];
        
        // Format guaranteed text
        const guaranteedText = guaranteed.map(g => {
          const rarityName = currentGameConfig.rarities.find(r => r.id === g.rarity)?.name || g.rarity;
          return `${g.count} ${rarityName}`;
        }).join(', ');
        
        return { packs, cards, guaranteed: guaranteedText };
      }, [currentSetConfig, currentGameConfig]);

      // Generate save key scoped to game/set
      const getSaveKey = useCallback((base) => {
        return `tcg-${currentGameId}-${currentSetId}-${base}`;
      }, [currentGameId, currentSetId]);

      const CORE_SAVE_KEY = useMemo(() => getSaveKey('save-v2'), [getSaveKey]);
      const readCoreSave = () => {
        try {
          const raw = localStorage.getItem(CORE_SAVE_KEY);
          if (!raw) return null;
          const obj = JSON.parse(raw);
          if (!obj || typeof obj !== 'object') return null;
          if (obj.version !== 2) return null;
          return obj;
        } catch (e) {
          return null;
        }
      };

      const writeCoreSave = (obj) => {
        try {
          localStorage.setItem(CORE_SAVE_KEY, JSON.stringify(obj));
        } catch (e) {}
      };

      const [collection, setCollection] = useState({});
      const [packCards, setPackCards] = useState([]);
      const [revealedCards, setRevealedCards] = useState([]);
      const [view, setView] = useState('home');
      const [menuOpen, setMenuOpen] = useState(false);
      
      // Track current opening pack's game/set for correct images
      const [openingPackGameId, setOpeningPackGameId] = useState(null);
      const [openingPackSetId, setOpeningPackSetId] = useState(null);

      // Pack ripping state
      const [packPhase, setPackPhase] = useState('sealed'); // sealed | ripping | stack | revealed
      const [ripProgress, setRipProgress] = useState(0); // 0-100 percentage
      const [isRipping, setIsRipping] = useState(false);
      const [ripStartX, setRipStartX] = useState(0);
      const [currentCardIndex, setCurrentCardIndex] = useState(0); // which card is on top of stack
      const [slidingCards, setSlidingCards] = useState([]); // cards currently animating off
      const [isPeeking, setIsPeeking] = useState(false);
      const packRef = useRef(null);

      const navigate = (nextView) => {
        setView(nextView);
        setMenuOpen(false);
        // Close any overlays/modals when navigating
        setSellConfirm(null);
        setEnlargedCard(null);
        setSelectedEvent(null);
      };
      const [allRevealed, setAllRevealed] = useState(false);
      const [collectionFilter, setCollectionFilter] = useState('all');
      const [collectionSearch, setCollectionSearch] = useState('');
      const [ownedFilter, setOwnedFilter] = useState('all'); // all | owned | unowned
      const [holoFilter, setHoloFilter] = useState('all');   // all | hasHolo | noHolo
      const [sortKey, setSortKey] = useState('owned');       // owned | name | rarity | value | holoValue | change | holoMult
      const [sortDir, setSortDir] = useState('desc');        // asc | desc
      const [hideUnknown, setHideUnknown] = useState(false);
      const [packCount, setPackCount] = useState(0);
      const [isLoaded, setIsLoaded] = useState(false);
      const [enlargedCard, setEnlargedCard] = useState(null);
      const [rations, setRations] = useState(0);
      const [marketValues, setMarketValues] = useState({});
      const [priceHistory, setPriceHistory] = useState({});
      const [sellConfirm, setSellConfirm] = useState(null);
      const [packInventory, setPackInventory] = useState([]);
      
      // Inspect sealed product modal state
      const [inspectProduct, setInspectProduct] = useState(null);
      
      // Collection filters for game/set
      const [collectionGameFilter, setCollectionGameFilter] = useState('all');
      const [collectionSetFilter, setCollectionSetFilter] = useState('all');
      
      // Sell tab filters
      const [sellGameFilter, setSellGameFilter] = useState('all');
      const [sellSetFilter, setSellSetFilter] = useState('all');
      
      // Track which game/sets have claimed free starter
      const [freeStartersClaimed, setFreeStartersClaimed] = useState(() => {
        try {
          const raw = localStorage.getItem('tcg-free-starters-claimed');
          if (raw) return JSON.parse(raw);
        } catch (e) {}
        return {};
      });

      // Sealed inventory is now nested: sealedInventory[gameId][setId][productType] = count
      const [sealedInventory, setSealedInventory] = useState(() => {
        try {
          // Try to load from global save key (not game/set scoped)
          const raw = localStorage.getItem('tcg-global-sealed-inventory');
          if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === 'object') return parsed;
          }
        } catch (e) {}
        return {};
      });


      const [purchaseConfirm, setPurchaseConfirm] = useState(null);
      const [holoMultipliers, setHoloMultipliers] = useState({});
      const [freeStarterClaimed, setFreeStarterClaimed] = useState(false);
      const [dailyShopPicks, setDailyShopPicks] = useState({});
      const [dailyShopDate, setDailyShopDate] = useState('');

      // ===== Inventory Helper Functions =====
      // Get sealed count for a specific game/set/product
      const getSealedCount = useCallback((gameId, setId, productType) => {
        return sealedInventory?.[gameId]?.[setId]?.[productType] || 0;
      }, [sealedInventory]);

      // Update sealed count for a specific game/set/product
      const updateSealedCount = useCallback((gameId, setId, productType, delta) => {
        setSealedInventory(prev => {
          const newInv = { ...prev };
          if (!newInv[gameId]) newInv[gameId] = {};
          if (!newInv[gameId][setId]) newInv[gameId][setId] = {};
          const current = newInv[gameId][setId][productType] || 0;
          newInv[gameId][setId][productType] = Math.max(0, current + delta);
          // Save to localStorage
          try {
            localStorage.setItem('tcg-global-sealed-inventory', JSON.stringify(newInv));
          } catch (e) {}
          return newInv;
        });
      }, []);

      // Get packs for current game/set only
      const currentGameSetPacks = useMemo(() => {
        return packInventory.filter(p => p.gameId === currentGameId && p.setId === currentSetId);
      }, [packInventory, currentGameId, currentSetId]);

      // Save pack inventory to localStorage (global, not game/set scoped)
      const saveGlobalPackInventory = useCallback((packs) => {
        try {
          localStorage.setItem('tcg-global-pack-inventory', JSON.stringify(packs));
        } catch (e) {}
      }, []);

      // Load pack inventory on mount
      useEffect(() => {
        try {
          const raw = localStorage.getItem('tcg-global-pack-inventory');
          if (raw) {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
              setPackInventory(parsed);
            }
          }
        } catch (e) {}
      }, []);
      const [shopStock, setShopStock] = useState(() => {
        try {
          const core = readCoreSave();
          if (core && core.shopStock) return core.shopStock;
        } catch (e) {}
        const raw = localStorage.getItem('tcg-shop-stock');
        if (raw) {
          try { return JSON.parse(raw); } catch (e) { return null; }
        }
        return null;
      });

      const [shopTab, setShopTab] = useState('buy'); // buy | sell
      const [shopSellSearch, setShopSellSearch] = useState('');
      const [shopSellFilter, setShopSellFilter] = useState('all'); // all | rarity
      const [shopSellVariant, setShopSellVariant] = useState('any'); // any | normal | holo
      const [shopSellSort, setShopSellSort] = useState('payout'); // payout | name | rarity | owned


      const [gameDay, setGameDay] = useState(() => {
        const v = parseInt(localStorage.getItem('tcg-game-day') || '1', 10);
        return (Number.isFinite(v) && v > 0) ? v : 1;
      });

      
      const [godPackActive, setGodPackActive] = useState(false);
      const [godPackConfetti, setGodPackConfetti] = useState([]);
      const [lastPackWasGod, setLastPackWasGod] = useState(false);
      const [showGodPackGate, setShowGodPackGate] = useState(false);
      const [eventLog, setEventLog] = useState([]);
      const [selectedEvent, setSelectedEvent] = useState(null);


      // ===== Settings / Save / Debug =====
      const [saveSeed, setSaveSeed] = useState(() => {
        const raw = localStorage.getItem('tcg-save-seed');
        const v = raw ? parseInt(raw, 10) : NaN;
        return Number.isFinite(v) && v > 0 ? v : 0;
      });
      const [debugEnabled, setDebugEnabled] = useState(() => {
        const raw = localStorage.getItem('tcg-debug-enabled');
        return raw === '1' || raw === 'true';
      });
      const [debugSeed, setDebugSeed] = useState(() => localStorage.getItem('tcg-debug-seed') || '');
      const rngFnRef = useRef(null);
      const rngSeedRef = useRef(null);
      const rngStateRef = useRef(null);


      const [settingsMsg, setSettingsMsg] = useState('');
      const [exportText, setExportText] = useState('');
      const [importText, setImportText] = useState('');

      // ===== Unified Core Save (v2) =====
      const updateCoreSave = (patch) => {
        try {
          const current = readCoreSave() || { format: 'tta-core', version: 2 };
          const next = { ...current, ...patch, version: 2, updatedAt: new Date().toISOString() };
          writeCoreSave(next);
          return next;
        } catch (e) {
          return null;
        }
      };


      const appendEvent = (evt) => {
        try {
          setEventLog(prev => {
            const next = [evt, ...prev].slice(0, 200);
            updateCoreSave({ events: next });
            return next;
          });
        } catch (e) {}
      };

      const getEventLabel = (evt) => {
        if (!evt || !evt.type) return 'Event';
        if (evt.type === 'godpack') return 'God Pack';
        return String(evt.type);
      };

      const summarizeGodPack = (evt) => {
        // Dynamic counting based on actual card rarities in the event
        const cards = Array.isArray(evt.cards) ? evt.cards : [];
        const counts = {};
        cards.forEach(c => {
          const r = c.rarity || 'unknown';
          counts[r] = (counts[r] || 0) + 1;
        });
        
        // Format the counts
        const parts = Object.entries(counts)
          .filter(([_, count]) => count > 0)
          .map(([rarity, count]) => {
            // Capitalize first letter of each word
            const label = rarity.split(/[-\s]/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            return `${count} ${label}`;
          });
        
        return parts.join(', ') || 'No cards';
      };

      const formatEventSummary = (evt) => {
        const day = evt && evt.day ? `Day ${evt.day}` : '';
        if (evt && evt.type === 'godpack') {
          return `${day} · ${summarizeGodPack(evt)}`;
        }
        return day;
      };

      const openEventDetails = (evt) => {
        setSelectedEvent(evt);
      };

      const closeEventDetails = () => setSelectedEvent(null);

      const dismissGodPackGate = () => setShowGodPackGate(false);

      const getActiveSeed = useCallback(() => {
        if (debugEnabled) {
          const v = parseInt(debugSeed || '', 10);
          if (Number.isFinite(v) && v > 0) return v;
        }
        return saveSeed;
      }, [debugEnabled, debugSeed, saveSeed]);

      const persistRngState = useCallback(() => {
        if (!debugEnabled) return;
        try {
          if (rngStateRef.current == null) return;
          localStorage.setItem('tcg-rng-state', String((rngStateRef.current >>> 0)));
          try { updateCoreSave({ debugSettings: { enabled: true, seed: String(debugSeed || ''), rngState: (rngStateRef.current >>> 0) } }); } catch (e) {}
        } catch (e) {}
      }, [debugEnabled]);

      const initSeededRng = useCallback(() => {
        const activeSeed = (getActiveSeed() >>> 0) || 0x12345678;

        let state = activeSeed;
        try {
          const savedStateRaw = localStorage.getItem('tcg-rng-state');
          if (savedStateRaw != null) {
            const parsed = parseInt(savedStateRaw, 10);
            if (Number.isFinite(parsed)) state = (parsed >>> 0);
          }
        } catch (e) {}

        rngSeedRef.current = activeSeed;
        rngStateRef.current = state;

        rngFnRef.current = () => {
          // Mulberry32 variant using in-memory state (persisted on major actions, not per call)
          let s = (rngStateRef.current >>> 0);
          s = (s + 0x6D2B79F5) >>> 0;
          let t = Math.imul(s ^ (s >>> 15), 1 | s);
          t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
          t = (t ^ (t >>> 14)) >>> 0;
          rngStateRef.current = s;
          return t / 4294967296;
        };
      }, [getActiveSeed]);

      const rand = useCallback(() => {
        if (!debugEnabled) return Math.random();
        const activeSeed = (getActiveSeed() >>> 0) || 0x12345678;
        if (!rngFnRef.current || rngSeedRef.current !== activeSeed) {
          initSeededRng();
        }
        return rngFnRef.current();
      }, [debugEnabled, getActiveSeed, initSeededRng]);

      const copyToClipboard = useCallback(async (textToCopy) => {
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(textToCopy);
            setSettingsMsg('Copied to clipboard.');
            setTimeout(() => setSettingsMsg(''), 1500);
            return true;
          }
        } catch (e) {}
        // Fallback
        try {
          const ta = document.createElement('textarea');
          ta.value = textToCopy;
          ta.style.position = 'fixed';
          ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          setSettingsMsg(ok ? 'Copied to clipboard.' : 'Copy failed.');
          setTimeout(() => setSettingsMsg(''), 1500);
          return ok;
        } catch (e) {
          setSettingsMsg('Copy failed.');
          setTimeout(() => setSettingsMsg(''), 1500);
          return false;
        }
      }, []);

      const buildSaveExport = useCallback(() => {
        // Prefer unified core save, but also include any remaining tcg-* keys for backwards compatibility
        let core = null;
        try { core = readCoreSave(); } catch (e) { core = null; }

        const keys = Object.keys(localStorage).filter(k => k.startsWith('tcg-') && k !== CORE_SAVE_KEY).sort();
        const payload = {
          format: 'tta-save',
          version: 2,
          exportedAt: new Date().toISOString(),
          core,
          keys: {}
        };
        keys.forEach(k => {
          payload.keys[k] = localStorage.getItem(k);
        });
        return JSON.stringify(payload, null, 2);
      }, []);

      const triggerDownload = useCallback((filename, content) => {
        try {
          const blob = new Blob([content], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        } catch (e) {}
      }, []);

      const exportSave = useCallback(() => {
        const json = buildSaveExport();
        setExportText(json);
        triggerDownload(`tta_save_day_${gameDay}.json`, json);
        setSettingsMsg('Save exported.');
        setTimeout(() => setSettingsMsg(''), 1500);
      }, [buildSaveExport, gameDay, triggerDownload]);

      const applyImportedSave = useCallback((jsonText) => {
        let parsed = null;
        try { parsed = JSON.parse(jsonText); } catch (e) { parsed = null; }
        if (!parsed) {
          setSettingsMsg('Import failed: invalid JSON.');
          setTimeout(() => setSettingsMsg(''), 2500);
          return;
        }

        // New unified export format
        if (parsed && parsed.format === 'tta-save' && parsed.version === 2) {
          try {
            if (parsed.core && typeof parsed.core === 'object') {
              const core = { ...parsed.core, version: 2, format: parsed.core.format || 'tta-core' };
              localStorage.setItem(CORE_SAVE_KEY, JSON.stringify(core));
            }
            if (parsed.keys && typeof parsed.keys === 'object') {
              Object.keys(parsed.keys).forEach(k => {
                if (!k.startsWith('tcg-')) return;
                if (k === CORE_SAVE_KEY) return;
                const v = parsed.keys[k];
                localStorage.setItem(k, (v === null || v === undefined) ? '' : String(v));
              });
            }
          } catch (e) {
            setSettingsMsg('Import failed: could not apply save.');
            setTimeout(() => setSettingsMsg(''), 2500);
            return;
          }
          setSettingsMsg('Save imported. Reloading…');
          setTimeout(() => window.location.reload(), 500);
          return;
        }

        // Legacy format: either {format:'tta-save', keys:{...}} or a raw object of keys
        const keysObj = (parsed && parsed.format === 'tta-save' && parsed.keys && typeof parsed.keys === 'object')
          ? parsed.keys
          : parsed;

        if (!keysObj || typeof keysObj !== 'object') {
          setSettingsMsg('Import failed: unexpected format.');
          setTimeout(() => setSettingsMsg(''), 2500);
          return;
        }

        Object.keys(keysObj).forEach(k => {
          if (!k.startsWith('tcg-')) return;
          const v = keysObj[k];
          localStorage.setItem(k, (v === null || v === undefined) ? '' : String(v));
        });

        setSettingsMsg('Save imported. Reloading…');
        setTimeout(() => window.location.reload(), 500);
      }, []);

      const resetAllSaveData = useCallback(() => {
        const ok = window.confirm('Reset ALL progress? This clears your local save and reloads the page.');
        if (!ok) return;
        Object.keys(localStorage).forEach(k => {
          if (k.startsWith('tcg-')) localStorage.removeItem(k);
        });
        window.location.reload();
      }, []);

      const applyDebugSettings = useCallback(() => {
        // Persist debug settings
        localStorage.setItem('tcg-debug-enabled', debugEnabled ? '1' : '0');
        localStorage.setItem('tcg-debug-seed', String(debugSeed || ''));
        try { updateCoreSave({ debugSettings: { enabled: !!debugEnabled, seed: String(debugSeed || ''), rngState: parseInt(localStorage.getItem('tcg-rng-state') || '0', 10) } }); } catch (e) {}
        // Reset RNG state to the active seed for clean reproducibility when requested
        const ok = window.confirm('Reset deterministic RNG stream now? (Recommended after changing seed)');
        if (ok) {
          const v = parseInt(debugSeed || '', 10);
          const active = (Number.isFinite(v) && v > 0 ? v : saveSeed) >>> 0;
          localStorage.setItem('tcg-rng-state', String(active >>> 0));
        try { updateCoreSave({ debugSettings: { enabled: !!debugEnabled, seed: String(debugSeed || ''), rngState: (active >>> 0) } }); } catch (e) {}
            try { rngStateRef.current = (active >>> 0); } catch (e) {}
          rngStateRef.current = (active >>> 0);
          rngFnRef.current = null;
          rngSeedRef.current = null;
        }
        setSettingsMsg('Debug settings saved.');
        setTimeout(() => setSettingsMsg(''), 1500);
      }, [debugEnabled, debugSeed, saveSeed]);

      const resetDeterministicStream = useCallback(() => {
        const active = (getActiveSeed() >>> 0) || 0x12345678;
        localStorage.setItem('tcg-rng-state', String(active >>> 0));
        try { updateCoreSave({ debugSettings: { enabled: !!debugEnabled, seed: String(debugSeed || ''), rngState: (active >>> 0) } }); } catch (e) {}
            try { rngStateRef.current = (active >>> 0); } catch (e) {}
        rngStateRef.current = (active >>> 0);
        rngFnRef.current = null;
        rngSeedRef.current = null;
        setSettingsMsg('Deterministic RNG stream reset.');
        setTimeout(() => setSettingsMsg(''), 1500);
      }, [getActiveSeed]);


      const handleImportFile = useCallback((file) => {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const t = (reader.result === null || reader.result === undefined) ? '' : String(reader.result);
          setImportText(t);
          setSettingsMsg('Loaded save JSON into the import box.');
          setTimeout(() => setSettingsMsg(''), 1500);
        };
        reader.onerror = () => {
          setSettingsMsg('Failed to read file.');
          setTimeout(() => setSettingsMsg(''), 2000);
        };
        reader.readAsText(file);
      }, []);





      // Generate weighted random value within range (bell curve distribution)
      const generateWeightedValue = (min, max, peak) => {
        // Use 3 random numbers averaged for bell curve effect
        const r1 = rand();
        const r2 = rand();
        const r3 = rand();
        const avg = (r1 + r2 + r3) / 3;
        
        // Weight towards peak
        const range = max - min;
        const peakOffset = peak - min;
        const peakRatio = peakOffset / range;
        
        // Adjust distribution to favor peak
        let value;
        if (avg < 0.5) {
          value = min + (avg * 2 * peakOffset);
        } else {
          value = peak + ((avg - 0.5) * 2 * (max - peak));
        }
        
        return parseFloat(value.toFixed(2));
      };

      const generateWeightedInt = (min, max, peak) => {
        const v = generateWeightedValue(min, max, peak);
        const n = Math.round(v);
        return Math.max(min, Math.min(max, n));
      };

      // Generate initial market values for all cards using config ranges
      const generateMarketValues = () => {
        const values = {};
        
        // Generate market values for ALL cards across ALL games/sets
        for (const [gameId, gameSets] of Object.entries(setConfigs)) {
          for (const [setId, setConfig] of Object.entries(gameSets)) {
            if (!setConfig || !setConfig.cards) continue;
            
            const ranges = setConfig.marketValueRanges || {};
            
            setConfig.cards.forEach(card => {
              // Skip if we already have a value for this card ID
              if (values[card.id] !== undefined) return;
              
              const range = ranges[card.rarity];
              let value;
              
              if (range) {
                value = generateWeightedValue(range.min, range.max, range.peak);
              } else {
                // Fallback for unknown rarities
                value = 1.0;
              }
              values[card.id] = value;
            });
          }
        }
        
        // Also include current set for backwards compatibility
        const ranges = currentSetConfig?.marketValueRanges || {};
        ALL_CARDS.forEach(card => {
          if (values[card.id] !== undefined) return;
          
          const range = ranges[card.rarity];
          let value;
          
          if (range) {
            value = generateWeightedValue(range.min, range.max, range.peak);
          } else {
            value = 1.0;
          }
          values[card.id] = value;
        });
        
        return values;
      }

      // Generate per-card holo multipliers using config ranges
      const generateHoloMultipliers = () => {
        const multipliers = {};
        
        // Generate for ALL cards across ALL games/sets
        for (const [gameId, gameSets] of Object.entries(setConfigs)) {
          const gameConfig = gameConfigs[gameId];
          const holoRange = gameConfig?.holoMultiplierRange || { min: 1.10, max: 2.50, peak: 1.50 };
          
          for (const [setId, setConfig] of Object.entries(gameSets)) {
            if (!setConfig || !setConfig.cards) continue;
            
            setConfig.cards.forEach(card => {
              if (multipliers[card.id] !== undefined) return;
              multipliers[card.id] = generateWeightedValue(holoRange.min, holoRange.max, holoRange.peak);
            });
          }
        }
        
        // Also include current game for backwards compatibility
        const holoRange = currentGameConfig?.holoMultiplierRange || { min: 1.10, max: 2.50, peak: 1.50 };
        ALL_CARDS.forEach(card => {
          if (multipliers[card.id] !== undefined) return;
          multipliers[card.id] = generateWeightedValue(holoRange.min, holoRange.max, holoRange.peak);
        });
        
        return multipliers;
      };

      const getBaseMarketValue = (cardId) => {
        return marketValues[cardId] || 1;
      };

      const getHoloMultiplier = (cardId) => {
        return holoMultipliers[cardId] || 1.50;
      };

      const getHoloMarketValue = (cardId) => {
        return getBaseMarketValue(cardId) * getHoloMultiplier(cardId);
      };

      // Use rarities from config for daily shop
      // Now picks 4 cards from any game/set based on price tiers
      const generateDailyShopPicks = () => {
        // Collect all cards from all loaded games/sets with their market values
        const allCardsWithPrices = [];
        
        for (const [gameId, gameSets] of Object.entries(setConfigs)) {
          const gameConfig = gameConfigs[gameId];
          if (!gameConfig) continue;
          
          for (const [setId, setConfig] of Object.entries(gameSets)) {
            if (!setConfig || !setConfig.cards) continue;
            
            for (const card of setConfig.cards) {
              // Use marketValueRanges to estimate price (use peak as estimate)
              const range = setConfig.marketValueRanges?.[card.rarity];
              const estimatedPrice = range?.peak || 1;
              
              allCardsWithPrices.push({
                id: card.id,
                name: card.name,
                rarity: card.rarity,
                gameId,
                setId,
                estimatedPrice,
                file: card.file
              });
            }
          }
        }
        
        // Define price tiers
        const tiers = [
          { key: 'budget', min: 0, max: 5 },
          { key: 'mid', min: 5, max: 25 },
          { key: 'premium', min: 25, max: 100 },
          { key: 'chase', min: 100, max: Infinity }
        ];
        
        const picks = {};
        
        for (const tier of tiers) {
          const eligible = allCardsWithPrices.filter(c => 
            c.estimatedPrice >= tier.min && c.estimatedPrice < tier.max
          );
          
          if (eligible.length > 0) {
            const pick = eligible[Math.floor(rand() * eligible.length)];
            picks[tier.key] = {
              cardId: pick.id,
              gameId: pick.gameId,
              setId: pick.setId,
              file: pick.file,
              rarity: pick.rarity
            };
          }
        }
        
        return picks;
      };

      // Price tier labels for display
      const DAILY_SHOP_TIERS = [
        { key: 'budget', label: 'Budget Pick', color: '#9ca3af' },
        { key: 'mid', label: 'Mid-Range', color: '#10b981' },
        { key: 'premium', label: 'Premium', color: '#3b82f6' },
        { key: 'chase', label: 'Chase Card', color: '#f59e0b' }
      ];

      const generateDailyShopStock = (day) => {
        const d = (day !== null && day !== undefined) ? day : gameDay;
        const singleLimit = generateWeightedInt(1, 15, 5);
        const bundleLimit = generateWeightedInt(1, 4, 1);
        const boosterLimit = generateWeightedInt(0, 3, 0);
        const caseLimit = generateWeightedInt(0, 1, 0);
        return {
          day: d,
          single: { limit: singleLimit, remaining: singleLimit },
          bundle: { limit: bundleLimit, remaining: bundleLimit },
          booster: { limit: boosterLimit, remaining: boosterLimit },
          case: { limit: caseLimit, remaining: caseLimit }
        };
      };

      // Get price for daily shop card - uses the card's own set config for pricing
      const getDailyShopPrice = (cardId, gameId, setId) => {
        // If we have market values for this card, use them
        if (marketValues[cardId]) {
          return parseFloat((marketValues[cardId] * 1.25).toFixed(2));
        }
        
        // Otherwise estimate from the card's set config
        const setConfig = setConfigs[gameId]?.[setId];
        if (setConfig) {
          const card = setConfig.cards?.find(c => c.id === cardId);
          if (card) {
            const range = setConfig.marketValueRanges?.[card.rarity];
            if (range) {
              // Use peak price with 25% markup
              return parseFloat((range.peak * 1.25).toFixed(2));
            }
          }
        }
        
        return 1.25; // Fallback
      };


      // ===== God Pack helpers =====
      // Get god pack chance from config, default to 1/1000
      const GOD_PACK_CHANCE = currentSetConfig.godPack?.chance || (1 / 1000);

      const triggerGodPackEffect = useCallback(() => {
        // Make a small burst of confetti + a quick glow overlay
        const pieces = Array.from({ length: 42 }, () => {
          const hue = Math.floor(rand() * 360);
          const left = (rand() * 100).toFixed(2) + 'vw';
          const dur = (1.2 + rand() * 1.0).toFixed(2) + 's';
          const delay = (rand() * 0.25).toFixed(2) + 's';
          const w = (6 + rand() * 10).toFixed(0) + 'px';
          const h = (8 + rand() * 14).toFixed(0) + 'px';
          const c = `hsl(${hue}, 90%, 60%)`;
          return { left, dur, delay, w, h, c };
        });

        setGodPackConfetti(pieces);
        setGodPackActive(true);

        window.clearTimeout(window.__tcgGodPackTO);
        window.__tcgGodPackTO = window.setTimeout(() => {
          setGodPackActive(false);
        }, 1700);
      }, []);

      const buyGodPack = () => {
        const newPacks = [{
          id: generatePackId(),
          type: 'godpack',
          isGodPack: true,
          gameId: currentGameId,
          setId: currentSetId
        }];
        const newInventory = [...packInventory, ...newPacks];
        setPackInventory(newInventory);
        savePackInventory(newInventory);
      };

      // Discard (delete) a card from the collection without gaining rations.
      const discardFromCollection = (cardId, variant = 'normal') => {
        const idStr = String(cardId);
        const entry = collection[idStr] || { normal: 0, holo: 0 };
        const next = { ...entry };

        if (variant === 'holo') next.holo = Math.max(0, (next.holo || 0) - 1);
        else next.normal = Math.max(0, (next.normal || 0) - 1);

        // If both are zero, remove the key
        const newCollection = { ...collection };
        if ((next.normal || 0) === 0 && (next.holo || 0) === 0) delete newCollection[idStr];
        else newCollection[idStr] = next;

        setCollection(newCollection);
        saveCollection(newCollection);

        // Keep enlargedCard counts in sync if we're currently inspecting the same card
        if (enlargedCard && String(enlargedCard.id) === idStr) {
          const ownedNormal = next.normal || 0;
          const ownedHolo = next.holo || 0;
          setEnlargedCard({ ...enlargedCard, ownedNormal, ownedHolo, owned: ownedNormal + ownedHolo });
        }
      };


      const normalizeCollection = (raw) => {
        const out = {};
        if (!raw || typeof raw !== 'object') return out;
        Object.entries(raw).forEach(([id, val]) => {
          if (typeof val === 'number') {
            if (val > 0) out[id] = { normal: val, holo: 0 };
            return;
          }
          if (val && typeof val === 'object') {
            const normal = Math.max(0, Number(val.normal ?? 0));
            const holo = Math.max(0, Number(val.holo ?? 0));
            if (normal > 0 || holo > 0) out[id] = { normal, holo };
          }
        });
        return out;
      };
;

      // Apply daily market fluctuation
      const fluctuateMarket = (baseValues, currentValues, breakoutCards) => {
        const newValues = { ...currentValues }; // Start with current values to preserve all cards
        
        // Fluctuate ALL cards in baseValues (which should include all games/sets)
        Object.keys(baseValues).forEach(cardId => {
          const baseValue = baseValues[cardId];
          const currentValue = currentValues[cardId] || baseValue;
          const isBreakout = breakoutCards.includes(cardId);
          
          // Random fluctuation between -15% and +15%
          const fluctuation = (rand() * 0.30) - 0.15; // -0.15 to +0.15
          let newValue = currentValue * (1 + fluctuation);
          
          // 90% of cards stay within 50-150% of base value
          if (!isBreakout) {
            const minBound = baseValue * 0.5;
            const maxBound = baseValue * 1.5;
            newValue = Math.max(minBound, Math.min(maxBound, newValue));
          } else {
            // 10% can break out to 25-200% of base value
            const minBound = baseValue * 0.25;
            const maxBound = baseValue * 2.0;
            newValue = Math.max(minBound, Math.min(maxBound, newValue));
          }
          
          newValues[cardId] = parseFloat(newValue.toFixed(2));
        });
        return newValues;
      };

      // Select 10% of cards from each rarity across ALL games/sets to be "breakout" cards
      const selectBreakoutCards = () => {
        const breakouts = [];
        const cardsByRarity = {};
        
        // Collect all cards from all games/sets by rarity
        for (const [gameId, gameSets] of Object.entries(setConfigs)) {
          for (const [setId, setConfig] of Object.entries(gameSets)) {
            if (!setConfig || !setConfig.cards) continue;
            
            setConfig.cards.forEach(card => {
              if (!cardsByRarity[card.rarity]) cardsByRarity[card.rarity] = [];
              // Avoid duplicates
              if (!cardsByRarity[card.rarity].find(c => c.id === card.id)) {
                cardsByRarity[card.rarity].push(card);
              }
            });
          }
        }
        
        Object.keys(cardsByRarity).forEach(rarity => {
          const cards = cardsByRarity[rarity];
          const count = Math.ceil(cards.length * 0.1);
          const shuffled = [...cards].sort(() => rand() - 0.5);
          breakouts.push(...shuffled.slice(0, count).map(c => c.id));
        });
        return breakouts;
      };

      useEffect(() => {
        // --- Boot from unified core save if present (v2) ---
        const coreBoot = readCoreSave();
        let bootDay = gameDay;
        let bootCollection = null;
        let bootPackCount = null;
        let bootRations = null;
        let bootPackInventory = null;
        let bootFreeStarter = null;
        let bootEvents = null;
        let bootShopStock = null;

        if (coreBoot) {
          const d = parseInt(coreBoot.gameDay || '1', 10);
          if (Number.isFinite(d) && d > 0) bootDay = d;
          bootCollection = coreBoot.collection || null;
          bootPackCount = coreBoot.packCount;
          bootRations = coreBoot.rations;
          bootPackInventory = coreBoot.packInventory;
          bootFreeStarter = coreBoot.freeStarterClaimed;
          bootEvents = Array.isArray(coreBoot.events) ? coreBoot.events : null;

          bootShopStock = coreBoot.shopStock || null;

          if (coreBoot.saveSeed) {
            try { localStorage.setItem('tcg-save-seed', String(coreBoot.saveSeed)); } catch (e) {}
            setSaveSeed(coreBoot.saveSeed);
          }
        }

        // Ensure game day key exists and is aligned (legacy key kept for compatibility)
        try { localStorage.setItem('tcg-game-day', String(bootDay)); } catch (e) {}
        if (bootDay !== gameDay) setGameDay(bootDay);

        // (bootDay already aligned above)


        // Initialize a stable seed for this save (used for deterministic testing)
        const existingSeedRaw = localStorage.getItem('tcg-save-seed');
        if (!existingSeedRaw) {
          const seed = Math.floor(Math.random() * 2147483647) + 1;
          localStorage.setItem('tcg-save-seed', String(seed));
          setSaveSeed(seed);
        } else {
          const seed = parseInt(existingSeedRaw, 10);
          if (Number.isFinite(seed) && seed > 0) setSaveSeed(seed);
        }

        // If debug mode is enabled, ensure deterministic RNG stream state exists
        const dbgEnabled = (localStorage.getItem('tcg-debug-enabled') === '1' || localStorage.getItem('tcg-debug-enabled') === 'true');
        if (dbgEnabled) {
          const dbgSeedRaw = localStorage.getItem('tcg-debug-seed') || '';
          const dbgSeedVal = parseInt(dbgSeedRaw, 10);
          const baseSeed = parseInt(localStorage.getItem('tcg-save-seed') || '0', 10);
          const active = ((Number.isFinite(dbgSeedVal) && dbgSeedVal > 0) ? dbgSeedVal : (Number.isFinite(baseSeed) && baseSeed > 0 ? baseSeed : 0x12345678)) >>> 0;
          if (!localStorage.getItem('tcg-rng-state')) {
            localStorage.setItem('tcg-rng-state', String(active >>> 0));
            try { rngStateRef.current = (active >>> 0); } catch (e) {}
          }
        }

        // Load saved data (prefer unified core save)
        if (bootCollection) {
          try {
            setCollection(normalizeCollection(bootCollection));
          } catch (e) {
            setCollection({});
          }
        } else {
          const saved = localStorage.getItem('tcg-collection-v3');
          if (saved) {
            try {
              setCollection(normalizeCollection(JSON.parse(saved)));
            } catch (e) {
              setCollection({});
            }
          }
        }

        if (bootPackCount !== null && bootPackCount !== undefined) {
          const pc = parseInt(String(bootPackCount), 10);
          if (Number.isFinite(pc)) setPackCount(pc);
        } else {
          const savedCount = localStorage.getItem('tcg-pack-count-v3');
          if (savedCount) setPackCount(parseInt(savedCount, 10));
        }

        if (bootRations !== null && bootRations !== undefined) {
          const rr = parseFloat(String(bootRations));
          if (Number.isFinite(rr)) setRations(rr);
        } else {
          const savedRations = localStorage.getItem('tcg-rations');
          if (savedRations) setRations(parseFloat(savedRations));
        }

        if (bootFreeStarter !== null && bootFreeStarter !== undefined) {
          setFreeStarterClaimed(!!bootFreeStarter);
        } else {
          const savedStarter = localStorage.getItem('tcg-free-starter-claimed');
          if (savedStarter) setFreeStarterClaimed(savedStarter === '1' || savedStarter === 'true');
        }

                // Load milestone/event log
        if (Array.isArray(bootEvents)) {
          setEventLog(bootEvents);
        } else {
          setEventLog([]);
        }

        // Load pack inventory (fixes refresh losing owned packs)
        if (Array.isArray(bootPackInventory)) {
          setPackInventory(bootPackInventory);
        } else {
          const invRaw = localStorage.getItem('tcg-pack-inventory');
          if (invRaw) {
            try {
              const inv = JSON.parse(invRaw);
              if (Array.isArray(inv)) setPackInventory(inv);
            } catch (e) {}
          }
        }

        // Initialize or load daily shop rotation (5 singles, 1 per rarity)
        let dsDate = localStorage.getItem('tcg-daily-shop-date');
        let dsPicksRaw = localStorage.getItem('tcg-daily-shop-picks');
        let dsPicks = null;
        if (dsPicksRaw) {
          try { dsPicks = JSON.parse(dsPicksRaw); } catch (e) { dsPicks = null; }
        }


        // Initialize or load market values
        let baseValues = localStorage.getItem('tcg-market-base');
        let currentValues = localStorage.getItem('tcg-market-current');
        let breakoutCards = localStorage.getItem('tcg-market-breakouts');
        let lastMarketDay = localStorage.getItem('tcg-market-last-day');
        let history = localStorage.getItem('tcg-price-history');
        
        const currentDay = bootDay;

        // Validate / rotate daily shop picks (advances by in-game Day, not real time)
        let dsDay = parseInt(localStorage.getItem('tcg-daily-shop-day') || '0', 10);
        if (!dsDay || dsDay !== currentDay || !dsPicks || typeof dsPicks !== 'object') {
          dsPicks = generateDailyShopPicks();
          dsDay = currentDay;
          localStorage.setItem('tcg-daily-shop-day', String(dsDay));
          localStorage.setItem('tcg-daily-shop-picks', JSON.stringify(dsPicks));
        }
        // No patching needed - just regenerate if day changed
        setDailyShopDate(`Day ${dsDay || currentDay}`);
        setDailyShopPicks(dsPicks || {});

        // Validate / rotate daily shop stock (in-game Day)
        try {
          let ss = bootShopStock;
          if (!ss) {
            const ssRaw = localStorage.getItem('tcg-shop-stock');
            if (ssRaw) { try { ss = JSON.parse(ssRaw); } catch (e) { ss = null; } }
          }
          if (!ss || typeof ss !== 'object' || ss.day !== currentDay || !ss.single || !ss.bundle || !ss.booster || !ss.case) {
            ss = generateDailyShopStock(currentDay);
          }
          try { localStorage.setItem('tcg-shop-stock', JSON.stringify(ss)); } catch (e) {}
          setShopStock(ss);
        } catch (e) {}

        // Initialize or load holo multipliers (foil premiums)
        let holoMap = {};
        const savedHolo = localStorage.getItem('tcg-holo-multipliers');
        if (!savedHolo) {
          holoMap = generateHoloMultipliers();
          localStorage.setItem('tcg-holo-multipliers', JSON.stringify(holoMap));
        } else {
          try {
            holoMap = JSON.parse(savedHolo) || {};
          } catch (e) {
            holoMap = {};
          }
          // Fill any missing card IDs from ALL games/sets
          let didPatch = false;
          for (const [gameId, gameSets] of Object.entries(setConfigs)) {
            const gameConfig = gameConfigs[gameId];
            const holoRange = gameConfig?.holoMultiplierRange || { min: 1.10, max: 2.50, peak: 1.50 };
            
            for (const [setId, setConfig] of Object.entries(gameSets)) {
              if (!setConfig || !setConfig.cards) continue;
              
              setConfig.cards.forEach(card => {
                if (!holoMap[card.id]) {
                  holoMap[card.id] = generateWeightedValue(holoRange.min, holoRange.max, holoRange.peak);
                  didPatch = true;
                }
              });
            }
          }
          if (didPatch) localStorage.setItem('tcg-holo-multipliers', JSON.stringify(holoMap));
        }
        
        // First time setup
        if (!baseValues) {
          baseValues = generateMarketValues();
          currentValues = { ...baseValues };
          breakoutCards = selectBreakoutCards();
          
          localStorage.setItem('tcg-market-base', JSON.stringify(baseValues));
          localStorage.setItem('tcg-market-current', JSON.stringify(currentValues));
          localStorage.setItem('tcg-market-breakouts', JSON.stringify(breakoutCards));
          localStorage.setItem('tcg-market-last-day', String(currentDay));
          
          // Initialize price history with today's prices
          const initialHistory = {};
          Object.keys(currentValues).forEach(cardId => {
            initialHistory[cardId] = [{ day: currentDay, value: currentValues[cardId] }];
          });
          localStorage.setItem('tcg-price-history', JSON.stringify(initialHistory));
          history = initialHistory;
        } else {
          baseValues = JSON.parse(baseValues);
          currentValues = JSON.parse(currentValues);
          breakoutCards = JSON.parse(breakoutCards);
          history = history ? JSON.parse(history) : {};
          
          // Patch in any missing cards from other games/sets
          let didPatchMarket = false;
          for (const [gameId, gameSets] of Object.entries(setConfigs)) {
            for (const [setId, setConfig] of Object.entries(gameSets)) {
              if (!setConfig || !setConfig.cards) continue;
              const ranges = setConfig.marketValueRanges || {};
              
              setConfig.cards.forEach(card => {
                if (baseValues[card.id] === undefined) {
                  const range = ranges[card.rarity];
                  const value = range 
                    ? generateWeightedValue(range.min, range.max, range.peak)
                    : 1.0;
                  baseValues[card.id] = value;
                  currentValues[card.id] = value;
                  history[card.id] = [{ day: currentDay, value }];
                  didPatchMarket = true;
                }
              });
            }
          }
          if (didPatchMarket) {
            localStorage.setItem('tcg-market-base', JSON.stringify(baseValues));
            localStorage.setItem('tcg-market-current', JSON.stringify(currentValues));
            localStorage.setItem('tcg-price-history', JSON.stringify(history));
          }
          
          // Prices only change when in-game Day advances (via the Advance Day button)
          let lastDayNum = parseInt(localStorage.getItem('tcg-market-last-day') || '0', 10);
          if (!lastDayNum || !Number.isFinite(lastDayNum)) {
            lastDayNum = currentDay;
            localStorage.setItem('tcg-market-last-day', String(currentDay));
          }

          // If the saved day is behind (e.g., after a reload), catch up one day at a time
          if (lastDayNum < currentDay) {
            for (let d = lastDayNum + 1; d <= currentDay; d++) {
              currentValues = fluctuateMarket(baseValues, currentValues, breakoutCards);
              // Update price history (keep last 30 days)
              Object.keys(currentValues).forEach(cardId => {
                if (!history[cardId]) history[cardId] = [];
                history[cardId].push({ day: d, value: currentValues[cardId] });
                history[cardId] = history[cardId].slice(-30);
              });
            }
            localStorage.setItem('tcg-market-current', JSON.stringify(currentValues));
            localStorage.setItem('tcg-market-last-day', String(currentDay));
            localStorage.setItem('tcg-price-history', JSON.stringify(history));
          }
        }
        
        setMarketValues(currentValues);
        setPriceHistory(history);
        setHoloMultipliers(holoMap);

        // Persist / refresh unified core save (v2). Market/history remain in existing keys for performance.
        try {
          let coreCollection = bootCollection;
          if (!coreCollection) {
            const rawCol = localStorage.getItem('tcg-collection-v3');
            if (rawCol) { try { coreCollection = normalizeCollection(JSON.parse(rawCol)); } catch (e) { coreCollection = {}; } }
          }
          if (!coreCollection) coreCollection = {};

          let corePackCount = (bootPackCount !== null && bootPackCount !== undefined) ? parseInt(String(bootPackCount), 10) : parseInt(localStorage.getItem('tcg-pack-count-v3') || '0', 10);
          if (!Number.isFinite(corePackCount)) corePackCount = 0;

          let coreRations = (bootRations !== null && bootRations !== undefined) ? parseFloat(String(bootRations)) : parseFloat(localStorage.getItem('tcg-rations') || '0');
          if (!Number.isFinite(coreRations)) coreRations = 0;

          let coreInv = Array.isArray(bootPackInventory) ? bootPackInventory : null;
          if (!coreInv) {
            const invRaw = localStorage.getItem('tcg-pack-inventory');
            if (invRaw) { try { const inv = JSON.parse(invRaw); if (Array.isArray(inv)) coreInv = inv; } catch (e) {} }
          }
          if (!Array.isArray(coreInv)) coreInv = [];

          const seedVal = parseInt(localStorage.getItem('tcg-save-seed') || '0', 10);
          const dbgEn = (localStorage.getItem('tcg-debug-enabled') === '1' || localStorage.getItem('tcg-debug-enabled') === 'true');
          const dbgSeed = localStorage.getItem('tcg-debug-seed') || '';
          const rngState = parseInt(localStorage.getItem('tcg-rng-state') || '0', 10);

          updateCoreSave({
            gameDay: currentDay,
            collection: coreCollection,
            packCount: corePackCount,
            rations: coreRations,
            packInventory: coreInv,
            shopStock: (function(){ try { const raw = localStorage.getItem('tcg-shop-stock'); return raw ? JSON.parse(raw) : undefined; } catch (e) { return undefined; } })(),
            freeStarterClaimed: (bootFreeStarter !== null && bootFreeStarter !== undefined) ? !!bootFreeStarter : (localStorage.getItem('tcg-free-starter-claimed') === '1' || localStorage.getItem('tcg-free-starter-claimed') === 'true'),
            saveSeed: Number.isFinite(seedVal) && seedVal > 0 ? seedVal : undefined,
            debugSettings: { enabled: dbgEn, seed: dbgSeed, rngState: Number.isFinite(rngState) ? rngState : undefined }
          });
        } catch (e) {}

        setIsLoaded(true);
      }, []);

      const saveCollection = useCallback((newCollection) => {
        try { localStorage.setItem('tcg-collection-v3', JSON.stringify(newCollection)); } catch (e) {}
        try { updateCoreSave({ collection: newCollection }); } catch (e) {}
      }, []);

      const savePackCount = useCallback((count) => {
        try { localStorage.setItem('tcg-pack-count-v3', String(count)); } catch (e) {}
        try { updateCoreSave({ packCount: count }); } catch (e) {}
      }, []);

      const saveRations = useCallback((amount) => {
        try { localStorage.setItem('tcg-rations', String(amount)); } catch (e) {}
        try { updateCoreSave({ rations: amount }); } catch (e) {}
      }, []);

      // Save pack inventory globally (packs have their own gameId/setId)
      const savePackInventory = useCallback((packs) => {
        try { localStorage.setItem('tcg-global-pack-inventory', JSON.stringify(packs)); } catch (e) {}
      }, []);

      // mutateSealedInventory is no longer needed - use updateSealedCount instead

      const shuffleIndices = (n) => {
        const a = Array.from({ length: n }, (_, i) => i);
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(rand() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      };

      // Universal function to open any sealed product into packs
      const openSealedProduct = useCallback((gameId, setId, productType) => {
        const count = getSealedCount(gameId, setId, productType);
        if (count <= 0) return;
        
        // Get the set config for this game/set
        const setConfig = setConfigs[gameId]?.[setId];
        if (!setConfig) return;
        
        const sealedConfig = setConfig.sealedProducts?.[productType];
        if (!sealedConfig) return;
        
        const packCount = sealedConfig.packs || 1;
        const guaranteed = sealedConfig.guaranteed || [];
        
        const batchId = `${productType}_${Date.now()}`;
        const newPacks = [];
        for (let i = 0; i < packCount; i++) {
          newPacks.push({ 
            id: generatePackId(), 
            type: productType, 
            gameId: gameId,
            setId: setId,
            batchId 
          });
        }
        
        // Apply guaranteed rarities
        if (guaranteed.length > 0) {
          const shuffled = shuffleIndices(packCount);
          let guaranteeIdx = 0;
          for (const g of guaranteed) {
            for (let i = 0; i < g.count; i++) {
              if (guaranteeIdx < packCount) {
                newPacks[shuffled[guaranteeIdx]].forceRarity = g.rarity;
                guaranteeIdx++;
              }
            }
          }
        }

        const newInventory = [...packInventory, ...newPacks];
        setPackInventory(newInventory);
        savePackInventory(newInventory);
        
        // Decrement sealed count
        updateSealedCount(gameId, setId, productType, -1);
      }, [getSealedCount, setConfigs, packInventory, savePackInventory, updateSealedCount]);

      // Legacy wrappers for backwards compatibility (used in some places)
      const openBundleBox = () => openSealedProduct(currentGameId, currentSetId, 'bundle');
      const openBoosterBox = () => openSealedProduct(currentGameId, currentSetId, 'booster');
      const openBoosterCase = () => openSealedProduct(currentGameId, currentSetId, 'case');


      const saveFreeStarterClaimed = useCallback((claimed) => {
        try { localStorage.setItem('tcg-free-starter-claimed', claimed ? '1' : '0'); } catch (e) {}
        try { updateCoreSave({ freeStarterClaimed: !!claimed }); } catch (e) {}
      }, []);

      const advanceDay = () => {
        const nextDay = gameDay + 1;
        localStorage.setItem('tcg-game-day', String(nextDay));
        setGameDay(nextDay);
        try { updateCoreSave({ gameDay: nextDay }); } catch (e) {}

        // Rotate market values for the new day
        try {
          let base = {};
          let breakout = {};
          let current = {};
          let history = {};
          const baseRaw = localStorage.getItem('tcg-market-base');
          const breakoutRaw = localStorage.getItem('tcg-market-breakouts');
          const currentRaw = localStorage.getItem('tcg-market-current');
          const historyRaw = localStorage.getItem('tcg-price-history');

          if (baseRaw) { try { base = JSON.parse(baseRaw) || {}; } catch (e) { base = {}; } }
          if (breakoutRaw) { try { breakout = JSON.parse(breakoutRaw) || {}; } catch (e) { breakout = {}; } }
          if (currentRaw) { try { current = JSON.parse(currentRaw) || {}; } catch (e) { current = {}; } }
          if (historyRaw) { try { history = JSON.parse(historyRaw) || {}; } catch (e) { history = {}; } }

          // Safety: if market not initialized yet, initialize it now
          if (!base || Object.keys(base).length === 0) {
            base = generateMarketValues();
            current = { ...base };
            breakout = selectBreakoutCards();
            localStorage.setItem('tcg-market-base', JSON.stringify(base));
            localStorage.setItem('tcg-market-breakouts', JSON.stringify(breakout));
          }
          if (!current || Object.keys(current).length === 0) current = { ...base };

          const newValues = fluctuateMarket(base, current, breakout);
          localStorage.setItem('tcg-market-current', JSON.stringify(newValues));
          localStorage.setItem('tcg-market-last-day', String(nextDay));

          Object.keys(newValues).forEach(cardId => {
            const arr = Array.isArray(history[cardId]) ? history[cardId] : [];
            arr.push({ day: nextDay, value: newValues[cardId] });
            history[cardId] = arr.slice(-30);
          });
          localStorage.setItem('tcg-price-history', JSON.stringify(history));

          setMarketValues(newValues);
          setPriceHistory(history);
        } catch (e) {
          console.error(e);
        }

        // Rotate daily shop picks for the new day
        try {
          const picks = generateDailyShopPicks();
          localStorage.setItem('tcg-daily-shop-day', String(nextDay));
          localStorage.setItem('tcg-daily-shop-picks', JSON.stringify(picks));
          setDailyShopPicks(picks);
          setDailyShopDate(`Day ${nextDay}`);
          const ss = generateDailyShopStock(nextDay);
          try { localStorage.setItem('tcg-shop-stock', JSON.stringify(ss)); } catch (e) {}
          setShopStock(ss);
          try { updateCoreSave({ shopStock: ss }); } catch (e) {}
        } catch (e) {
          console.error(e);
        }
      

        // Persist deterministic RNG state after advancing the day (debug mode only)
        persistRngState();
};




      // Generate unique pack ID
      const generatePackId = () => {
        return `pack_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      };


      // ----------------------------
      // Sealed market pricing (BaseSet1)
      // - Pack price is anchored to 10 Rations on Day 1 and scales with expected pack value (EV)
      // - Sealed appreciates slowly with set age (independent of card day-to-day volatility)
      // ----------------------------
      const SEALED_SET_ID = 'BaseSet1';
      const SEALED_BASE_PACK_PRICE = 10; // Day 1 anchor price
      const SEALED_APPRECIATION_RATE_PER_DAY = 0.0002; // ~7.6%/yr

      const sealedMarket = useMemo(() => {
        const round2 = (n) => (Math.round((n + Number.EPSILON) * 100) / 100);

        const getValuesObj = (raw) => {
          if (!raw) return null;
          try { return JSON.parse(raw) || null; } catch (e) { return null; }
        };

        const baseValues = getValuesObj(localStorage.getItem('tcg-market-base')) || {};
        const currentValues = marketValues || {};

        const getVal = (vals, cardId) => {
          const v = vals && vals[cardId];
          return Number.isFinite(v) ? v : 0;
        };

        const avgRarity = (vals, rarity, includeHolo = false) => {
          const arr = CARDS_BY_RARITY[rarity] || [];
          if (!arr.length) return 0;
          let sum = 0;
          for (let i = 0; i < arr.length; i++) {
            const card = arr[i];
            const base = getVal(vals, card.id);
            const mult = includeHolo ? (Number.isFinite(holoMultipliers[card.id]) ? holoMultipliers[card.id] : 1.50) : 1;
            sum += base * mult;
          }
          return sum / arr.length;
        };

        const expectedPackEV = (vals) => {
          // Config-driven pack EV calculation
          const packStructure = currentSetConfig.packStructure;
          let totalEV = 0;
          
          for (const slot of packStructure.slots) {
            const count = slot.count || 1;
            
            if (slot.type === 'guaranteed') {
              // Guaranteed rarity slot
              const ev = avgRarity(vals, slot.rarity, false);
              totalEV += count * ev;
            } else if (slot.type === 'weighted' || slot.type === 'rare-slot') {
              // Weighted rarity slot
              let slotEV = 0;
              const odds = slot.odds || {};
              const totalOdds = Object.values(odds).reduce((a, b) => a + b, 0);
              
              for (const [rarity, chance] of Object.entries(odds)) {
                const weight = chance / totalOdds;
                // For rare-slot type, check if it has holoChance
                const holoChance = slot.holoChance || 0;
                const normalEV = avgRarity(vals, rarity, false);
                const holoEV = avgRarity(vals, rarity, true);
                slotEV += weight * ((1 - holoChance) * normalEV + holoChance * holoEV);
              }
              totalEV += count * slotEV;
            } else if (slot.type === 'holo') {
              // Holo slot (always holo)
              let slotEV = 0;
              const odds = slot.odds || {};
              const totalOdds = Object.values(odds).reduce((a, b) => a + b, 0);
              
              for (const [rarity, chance] of Object.entries(odds)) {
                const weight = chance / totalOdds;
                slotEV += weight * avgRarity(vals, rarity, true);
              }
              totalEV += count * slotEV;
            }
          }
          
          return totalEV;
        };

        const baseEV = expectedPackEV(baseValues);
        const curEV = expectedPackEV(currentValues);
        const ratio = (baseEV > 0) ? (curEV / baseEV) : 1;

        // Set release day (for future multi-set support). Default Day 1.
        let releaseDay = 1;
        try {
          const raw = localStorage.getItem(`tcg-set-release-day-${SEALED_SET_ID}`);
          const d = parseInt(raw || '1', 10);
          if (Number.isFinite(d) && d > 0) releaseDay = d;
          localStorage.setItem(`tcg-set-release-day-${SEALED_SET_ID}`, String(releaseDay));
        } catch (e) {}

        const age = Math.max(1, (gameDay || 1) - releaseDay + 1);
        const appreciation = Math.pow(1 + SEALED_APPRECIATION_RATE_PER_DAY, age - 1);

        // Market pack price (anchored to SEALED_BASE_PACK_PRICE at Day 1 base EV)
        const pack = round2(SEALED_BASE_PACK_PRICE * appreciation * Math.max(1, ratio));

        // Your discount rules:
        // bundles = value of 8 packs - 0.5 pack (7.5 packs)
        // booster boxes = value of 20 packs (4 "free")
        // cases = value of 100 packs (44 "free")
        const prices = {
          single: pack,
          bundle: round2(pack * 7.5),
          booster: round2(pack * 20),
          case: round2(pack * 100)
        };

        return {
          age,
          appreciation: round2(appreciation),
          baseEV: round2(baseEV),
          curEV: round2(curEV),
          prices
        };
      }, [marketValues, holoMultipliers, gameDay]);

      // Calculate prices for any game/set's products (simplified pricing for non-current sets)
      const getProductPrice = useCallback((gameId, setId, productType) => {
        // For current set, use sealedMarket prices
        if (gameId === currentGameId && setId === currentSetId && sealedMarket?.prices?.[productType]) {
          return sealedMarket.prices[productType];
        }
        
        // For other sets, use base pricing (could be enhanced later with per-set market simulation)
        const setConfig = setConfigs[gameId]?.[setId];
        if (!setConfig) return 10;
        
        const productConfig = setConfig.sealedProducts?.[productType];
        if (!productConfig) return 10;
        
        const packCount = productConfig.packs || 1;
        const basePricePerPack = 10; // Base price per pack
        
        // Apply simple discount for bulk
        let multiplier = 1;
        if (packCount >= 100) multiplier = 0.85;
        else if (packCount >= 20) multiplier = 0.90;
        else if (packCount >= 5) multiplier = 0.95;
        
        return Math.round(packCount * basePricePerPack * multiplier * 100) / 100;
      }, [currentGameId, currentSetId, sealedMarket, setConfigs]);

      // Get all products across all games/sets for shop display
      const allShopProducts = useMemo(() => {
        const products = [];
        
        for (const game of (gamesIndex?.games || [])) {
          if (!game.enabled) continue;
          const gameConfig = gameConfigs[game.id];
          if (!gameConfig) continue;
          
          for (const setId of gameConfig.sets) {
            const setConfig = setConfigs[game.id]?.[setId];
            if (!setConfig) continue;
            
            const sealedProducts = setConfig.sealedProducts || {};
            
            for (const [productType, productConfig] of Object.entries(sealedProducts)) {
              products.push({
                gameId: game.id,
                gameName: game.name,
                setId: setId,
                setName: setConfig.name,
                productType,
                productName: productConfig.name || productType,
                packs: productConfig.packs || 1,
                guaranteed: productConfig.guaranteed || [],
                cardback: gameConfig.cardback,
                packSize: setConfig.packStructure?.size || 8
              });
            }
          }
        }
        
        return products;
      }, [gamesIndex, gameConfigs, setConfigs]);

      // Universal function to buy any sealed product
      const buyProduct = useCallback((gameId, setId, productType, cost) => {
        if (rations < cost) return;
        
        const newPack = {
          id: generatePackId(),
          type: productType,
          gameId: gameId,
          setId: setId
        };

        const newInventory = [...packInventory, newPack];
        const newRations = parseFloat((rations - cost).toFixed(2));

        setPackInventory(newInventory);
        setRations(newRations);
        savePackInventory(newInventory);
        saveRations(newRations);
      }, [rations, packInventory, savePackInventory, saveRations]);

      // Universal function to buy sealed products that go into sealed inventory
      const buySealedProduct = useCallback((gameId, setId, productType, cost) => {
        if (rations < cost) return;
        
        const newRations = parseFloat((rations - cost).toFixed(2));
        setRations(newRations);
        saveRations(newRations);
        
        updateSealedCount(gameId, setId, productType, 1);
      }, [rations, saveRations, updateSealedCount]);

      // Legacy: Buy single pack for current game/set
      const buySinglePack = () => {
        const cost = (sealedMarket && sealedMarket.prices && Number.isFinite(sealedMarket.prices.single)) ? sealedMarket.prices.single : 10;
        buyProduct(currentGameId, currentSetId, 'single', cost);
      };

      
      // Claim free starter box (5 packs, one-time) - uses current game/set
      const claimFreeStarterBox = () => {
        if (freeStarterClaimed) return;

        const newPacks = [];
        for (let i = 0; i < 5; i++) {
          newPacks.push({ 
            id: generatePackId(), 
            type: 'starter',
            gameId: currentGameId,
            setId: currentSetId
          });
        }

        const newInventory = [...packInventory, ...newPacks];
        setPackInventory(newInventory);
        savePackInventory(newInventory);

        setFreeStarterClaimed(true);
        saveFreeStarterClaimed(true);
      };

      // Game/set-specific free starter
      const claimFreeStarterForSet = (gameId, setId) => {
        const claimKey = `${gameId}-${setId}`;
        if (freeStartersClaimed[claimKey]) return;

        const newPacks = [];
        for (let i = 0; i < 5; i++) {
          newPacks.push({ 
            id: generatePackId(), 
            type: 'starter',
            gameId: gameId,
            setId: setId
          });
        }

        const newInventory = [...packInventory, ...newPacks];
        setPackInventory(newInventory);
        savePackInventory(newInventory);

        const newClaimed = { ...freeStartersClaimed, [claimKey]: true };
        setFreeStartersClaimed(newClaimed);
        localStorage.setItem('tcg-free-starters-claimed', JSON.stringify(newClaimed));
      };

      // Game/set-specific god pack
      const buyGodPackForSet = (gameId, setId) => {
        const newPack = { 
          id: generatePackId(), 
          type: 'godpack',
          gameId: gameId,
          setId: setId
        };

        const newInventory = [...packInventory, newPack];
        setPackInventory(newInventory);
        savePackInventory(newInventory);
      };

      // Buy a daily rotating single (non-holo), 25% markup
      const buyDailyShopCard = (cardId, cost) => {
        if (!cardId) return;
        if (rations < cost) return;

        const newCollection = { ...collection };
        const entry = newCollection[cardId] || { normal: 0, holo: 0 };
        entry.normal = (entry.normal || 0) + 1;
        newCollection[cardId] = entry;

        const newRations = parseFloat((rations - cost).toFixed(2));
        setCollection(newCollection);
        saveCollection(newCollection);
        setRations(newRations);
        saveRations(newRations);
      };

// Legacy buy functions - use buySealedProduct
      const buyBundleBox = () => {
        const cost = (sealedMarket && sealedMarket.prices && Number.isFinite(sealedMarket.prices.bundle)) ? sealedMarket.prices.bundle : 75;
        buySealedProduct(currentGameId, currentSetId, 'bundle', cost);
      };

      const buyBoosterBox = () => {
        const cost = (sealedMarket && sealedMarket.prices && Number.isFinite(sealedMarket.prices.booster)) ? sealedMarket.prices.booster : 200;
        buySealedProduct(currentGameId, currentSetId, 'booster', cost);
      };

      const buyBoosterCase = () => {
        const cost = (sealedMarket && sealedMarket.prices && Number.isFinite(sealedMarket.prices.case)) ? sealedMarket.prices.case : 1000;
        buySealedProduct(currentGameId, currentSetId, 'case', cost);
      };

const persistShopStock = (ss) => {
        try { localStorage.setItem('tcg-shop-stock', JSON.stringify(ss)); } catch (e) {}
        try { updateCoreSave({ shopStock: ss }); } catch (e) {}
      };

      const consumeShopStock = (type) => {
        const map = { single: 'single', bundle: 'bundle', booster: 'booster', case: 'case' };
        const key = map[type] || null;
        if (!key) return true;

        let ss = shopStock;
        if (!ss || typeof ss !== 'object' || ss.day !== gameDay || !ss[key]) {
          ss = generateDailyShopStock(gameDay);
          try { localStorage.setItem('tcg-shop-stock', JSON.stringify(ss)); } catch (e) {}
        }

        const sku = ss[key];
        const remaining = sku && Number.isFinite(sku.remaining) ? sku.remaining : 0;
        if (remaining <= 0) {
          alert('Sold out today. Advance Day to restock.');
          setPurchaseConfirm(null);
          setShopStock(ss);
          persistShopStock(ss);
          return false;
        }

        const next = { ...ss, [key]: { ...sku, remaining: remaining - 1 } };
        setShopStock(next);
        persistShopStock(next);
        return true;
      };

      const confirmPurchase = () => {
        if (!purchaseConfirm) return;
        
        // Handle universal product purchases with gameId/setId
        if (purchaseConfirm.gameId && purchaseConfirm.setId && purchaseConfirm.productType) {
          const { gameId, setId, productType, cost, isSealedProduct } = purchaseConfirm;
          if (isSealedProduct) {
            // This goes into sealed inventory (bundles, boxes, cases)
            buySealedProduct(gameId, setId, productType, cost);
          } else {
            // This goes directly into pack inventory (single packs)
            buyProduct(gameId, setId, productType, cost);
          }
          setPurchaseConfirm(null);
          persistRngState();
          return;
        }
        
        // Legacy handling for old purchase types
        switch (purchaseConfirm.type) {
          case 'single':
            if (!consumeShopStock('single')) break;
            buySinglePack();
            break;
          case 'bundle':
            if (!consumeShopStock('bundle')) break;
            buyBundleBox();
            break;
          case 'booster':
            if (!consumeShopStock('booster')) break;
            buyBoosterBox();
            break;
          case 'case':
            if (!consumeShopStock('case')) break;
            buyBoosterCase();
            break;
          case 'freeStarter':
            claimFreeStarterForSet(purchaseConfirm.gameId, purchaseConfirm.setId);
            break;
          case 'dailyCard':
            buyDailyShopCard(purchaseConfirm.cardId, purchaseConfirm.cost);
            break;
          case 'godpack':
            buyGodPackForSet(purchaseConfirm.gameId, purchaseConfirm.setId);
            break;

          default:
            break;
        }
        // Persist deterministic RNG state after a purchase (debug mode only)
        persistRngState();
        setPurchaseConfirm(null);
      };
;

      const getRandomCard = (rarity) => {
        const cards = CARDS_BY_RARITY[rarity];
        if (!cards || cards.length === 0) return null;
        const card = cards[Math.floor(rand() * cards.length)];
        return { ...card, image: getImageUrl(card) };
      };

      
      const getCardById = (cardId) => {
        const idStr = String(cardId);
        const card = ALL_CARDS.find(c => String(c.id) === idStr);
        if (!card) return null;
        return { ...card, image: getImageUrl(card) };
      };

const getRareSlotCard = () => {
        // Get weighted slot config from pack structure
        const packStructure = currentSetConfig.packStructure;
        const weightedSlot = packStructure.slots.find(s => s.type === 'weighted' || s.type === 'rare-slot');
        
        if (!weightedSlot || !weightedSlot.odds) {
          // Fallback to rare
          return getRandomCard('rare');
        }
        
        const odds = weightedSlot.odds;
        const roll = rand() * 100;
        let cumulative = 0;
        
        for (const [rarity, chance] of Object.entries(odds)) {
          cumulative += chance;
          if (roll < cumulative) {
            return getRandomCard(rarity);
          }
        }
        
        // Fallback to first rarity in odds
        return getRandomCard(Object.keys(odds)[0]);
      }

      // Get card from holo/foil slot using config odds
      const getFoilSlotCard = () => {
        const packStructure = currentSetConfig.packStructure;
        const holoSlot = packStructure.slots.find(s => s.type === 'holo');
        
        if (!holoSlot || !holoSlot.odds) {
          // Fallback behavior
          return getRandomCard('common');
        }
        
        const odds = holoSlot.odds;
        const roll = rand() * 100;
        let cumulative = 0;
        
        for (const [rarity, chance] of Object.entries(odds)) {
          cumulative += chance;
          if (roll < cumulative) {
            return getRandomCard(rarity);
          }
        }
        
        return getRandomCard(Object.keys(odds)[0]);
      }
;

      // Open a specific pack by ID (for use from inventory modal)
      const openSpecificPack = (packId) => {
        console.log('openSpecificPack called with packId:', packId);
        console.log('Current packInventory:', packInventory);
        
        const packIndex = packInventory.findIndex(p => p.id === packId);
        console.log('Found pack at index:', packIndex);
        
        if (packIndex === -1) {
          console.error('Pack not found:', packId);
          return;
        }
        
        const packToOpen = packInventory[packIndex];
        console.log('Pack to open:', packToOpen);
        
        // Remove this pack from inventory
        const newInventory = [...packInventory];
        newInventory.splice(packIndex, 1);

        // Get the pack's game/set config
        const packGameId = packToOpen.gameId || currentGameId;
        const packSetId = packToOpen.setId || currentSetId;
        console.log('Using game/set:', packGameId, packSetId);
        
        const packGameConfig = gameConfigs[packGameId];
        const packSetConfig = setConfigs[packGameId]?.[packSetId];
        console.log('Configs:', { packGameConfig, packSetConfig });
        
        if (!packSetConfig || !packGameConfig) {
          console.error('Missing config for pack', packGameId, packSetId, { packGameConfig, packSetConfig });
          return;
        }

        const packStructure = packSetConfig.packStructure;
        if (!packStructure || !packStructure.slots) {
          console.error('Missing packStructure or slots for', packGameId, packSetId, packStructure);
          return;
        }
        
        console.log('Pack structure:', packStructure);
        
        const godPackConfig = packSetConfig.godPack;
        const godPackChance = godPackConfig?.chance || (1 / 1000);
        
        // Build cards by rarity for this specific set
        const packCardsByRarity = {};
        packGameConfig.rarityOrder.forEach(r => {
          packCardsByRarity[r] = packSetConfig.cards.filter(c => c.rarity === r);
        });
        
        // Helper to get random card from this pack's card pool
        const getPackCard = (rarity) => {
          const pool = packCardsByRarity[rarity] || [];
          if (pool.length === 0) return null;
          const card = pool[Math.floor(rand() * pool.length)];
          return {
            ...card,
            image: buildImageUrl(packGameId, packSetId, card)
          };
        };
        
        // Helper to get rare slot card for this pack
        const getPackRareSlotCard = () => {
          const weightedSlot = packStructure.slots.find(s => s.type === 'weighted' || s.type === 'rare-slot');
          if (!weightedSlot || !weightedSlot.odds) {
            return getPackCard('rare');
          }
          const odds = weightedSlot.odds;
          const roll = rand() * 100;
          let cumulative = 0;
          for (const [rarity, chance] of Object.entries(odds)) {
            cumulative += chance;
            if (roll < cumulative) {
              return getPackCard(rarity);
            }
          }
          return getPackCard(Object.keys(odds)[0]);
        };
        
        // Helper to get foil slot card for this pack
        const getPackFoilSlotCard = () => {
          const holoSlot = packStructure.slots.find(s => s.type === 'holo');
          if (!holoSlot || !holoSlot.odds) {
            return getPackCard('common');
          }
          const odds = holoSlot.odds;
          const roll = rand() * 100;
          let cumulative = 0;
          for (const [rarity, chance] of Object.entries(odds)) {
            cumulative += chance;
            if (roll < cumulative) {
              return getPackCard(rarity);
            }
          }
          return getPackCard(Object.keys(odds)[0]);
        };

        // Determine if this is a God Pack
        const isGodPack = !!packToOpen.isGodPack || packToOpen.type === 'godpack' || (rand() < godPackChance);
        setLastPackWasGod(isGodPack);
        if (isGodPack) {
          setShowGodPackGate(true);
          triggerGodPackEffect();
        }

        const newPack = [];

        if (isGodPack && godPackConfig) {
          // God Pack: use config distribution
          let slot = 0;
          const distribution = godPackConfig.distribution || [];
          
          for (const dist of distribution) {
            for (let i = 0; i < dist.count; i++) {
              const card = getPackCard(dist.rarity);
              if (card) {
                newPack.push({ 
                  ...card, 
                  slot: slot++, 
                  isHolo: godPackConfig.allHolo !== false, 
                  isGodPack: true 
                });
              }
            }
          }

          // Safety: fill remaining slots if needed
          const targetSize = godPackConfig.size || packStructure.size;
          while (newPack.length < targetSize) {
            const fallbackRarity = distribution.length > 0 ? distribution[0].rarity : 'rare';
            const fallback = getPackCard(fallbackRarity);
            if (!fallback) break;
            newPack.push({ ...fallback, slot: slot++, isHolo: true, isGodPack: true });
          }

          // Shuffle slightly so the sequence isn't always identical
          newPack.sort(() => rand() - 0.5);
          newPack.forEach((c, i) => c.slot = i);
        } else {
          // Normal pack: use config structure
          let slotIndex = 0;
          
          for (const slotConfig of packStructure.slots) {
            const count = slotConfig.count || 1;
            
            if (slotConfig.type === 'guaranteed') {
              // Guaranteed rarity cards
              for (let i = 0; i < count; i++) {
                const card = getPackCard(slotConfig.rarity);
                if (card) newPack.push({ ...card, slot: slotIndex++ });
              }
            } else if (slotConfig.type === 'weighted' || slotConfig.type === 'rare-slot') {
              // Weighted rarity slot
              for (let i = 0; i < count; i++) {
                if (packToOpen.forceRarity) {
                  // Guaranteed rarity from sealed product
                  const guaranteedCard = getPackCard(packToOpen.forceRarity);
                  if (guaranteedCard) newPack.push({ ...guaranteedCard, slot: slotIndex++ });
                } else {
                  const card = getPackRareSlotCard();
                  if (card) {
                    // Check if this slot has a holo chance (for SP-style rare slots)
                    const isHolo = slotConfig.holoChance && rand() < slotConfig.holoChance;
                    newPack.push({ ...card, slot: slotIndex++, isHolo });
                  }
                }
              }
            } else if (slotConfig.type === 'holo') {
              // Holo slot - always holo
              for (let i = 0; i < count; i++) {
                const foilCard = getPackFoilSlotCard();
                if (foilCard) newPack.push({ ...foilCard, slot: slotIndex++, isHolo: true, isFoilSlot: true });
              }
            }
          }
        }

        // Record milestone events
        if (isGodPack) {
          appendEvent({
            id: `gp-${gameDay || 1}-${packCount + 1}-${Math.floor(rand() * 1e9)}`,
            type: 'godpack',
            game: packGameId,
            set: packSetId,
            day: gameDay || 1,
            packIndex: packCount + 1,
            cards: newPack.map(c => ({ id: c.id, rarity: c.rarity, isHolo: !!c.isHolo, holoMult: c.holoMult || null }))
          });
        }

        console.log('Generated pack with', newPack.length, 'cards:', newPack);

        // Preload all images in the pack for instant display
        newPack.forEach(card => {
          const img = new Image();
          img.src = card.image;
        });

        // Update state
        console.log('Updating state and navigating to opening...');
        setPackInventory(newInventory);
        savePackInventory(newInventory);
        setPackCards(newPack);
        setRevealedCards([]);
        setPackPhase('sealed');
        setRipProgress(0);
        setCurrentCardIndex(0);
        setSlidingCards([]);
        setOpeningPackGameId(packGameId);
        setOpeningPackSetId(packSetId);
        setPackCount(prev => {
          const next = prev + 1;
          savePackCount(next);
          return next;
        });
        navigate('opening');
        console.log('Navigation complete');
      };

      const openPack = () => {
        // Check if we have packs for current game/set
        if (currentGameSetPacks.length === 0) return;

        // Take the first pack for current game/set from inventory
        const packToOpen = currentGameSetPacks[0];
        
        // Remove this pack from the global inventory
        const packIndex = packInventory.findIndex(p => p.id === packToOpen.id);
        const newInventory = [...packInventory];
        newInventory.splice(packIndex, 1);

        // Get the pack's game/set config (should match current since we filtered)
        const packGameId = packToOpen.gameId || currentGameId;
        const packSetId = packToOpen.setId || currentSetId;
        const packGameConfig = gameConfigs[packGameId];
        const packSetConfig = setConfigs[packGameId]?.[packSetId];
        
        if (!packSetConfig || !packGameConfig) {
          console.error('Missing config for pack', packGameId, packSetId);
          return;
        }

        const packStructure = packSetConfig.packStructure;
        const godPackConfig = packSetConfig.godPack;
        const godPackChance = godPackConfig?.chance || (1 / 1000);
        
        // Build cards by rarity for this specific set
        const packCardsByRarity = {};
        packGameConfig.rarityOrder.forEach(r => {
          packCardsByRarity[r] = packSetConfig.cards.filter(c => c.rarity === r);
        });
        
        // Helper to get random card from this pack's card pool
        const getPackCard = (rarity) => {
          const pool = packCardsByRarity[rarity] || [];
          if (pool.length === 0) return null;
          const card = pool[Math.floor(rand() * pool.length)];
          return {
            ...card,
            image: buildImageUrl(packGameId, packSetId, card)
          };
        };
        
        // Helper to get rare slot card for this pack
        const getPackRareSlotCard = () => {
          const weightedSlot = packStructure.slots.find(s => s.type === 'weighted' || s.type === 'rare-slot');
          if (!weightedSlot || !weightedSlot.odds) {
            return getPackCard('rare');
          }
          const odds = weightedSlot.odds;
          const roll = rand() * 100;
          let cumulative = 0;
          for (const [rarity, chance] of Object.entries(odds)) {
            cumulative += chance;
            if (roll < cumulative) {
              return getPackCard(rarity);
            }
          }
          return getPackCard(Object.keys(odds)[0]);
        };
        
        // Helper to get foil slot card for this pack
        const getPackFoilSlotCard = () => {
          const holoSlot = packStructure.slots.find(s => s.type === 'holo');
          if (!holoSlot || !holoSlot.odds) {
            return getPackCard('common');
          }
          const odds = holoSlot.odds;
          const roll = rand() * 100;
          let cumulative = 0;
          for (const [rarity, chance] of Object.entries(odds)) {
            cumulative += chance;
            if (roll < cumulative) {
              return getPackCard(rarity);
            }
          }
          return getPackCard(Object.keys(odds)[0]);
        };

        // Determine if this is a God Pack
        const isGodPack = !!packToOpen.isGodPack || (rand() < godPackChance);
        setLastPackWasGod(isGodPack);
        if (isGodPack) {
          setShowGodPackGate(true);
          triggerGodPackEffect();
        }

        const newPack = [];

        if (isGodPack && godPackConfig) {
          // God Pack: use config distribution
          let slot = 0;
          const distribution = godPackConfig.distribution || [];
          
          for (const dist of distribution) {
            for (let i = 0; i < dist.count; i++) {
              const card = getPackCard(dist.rarity);
              if (card) {
                newPack.push({ 
                  ...card, 
                  slot: slot++, 
                  isHolo: godPackConfig.allHolo !== false, 
                  isGodPack: true 
                });
              }
            }
          }

          // Safety: fill remaining slots if needed
          const targetSize = godPackConfig.size || packStructure.size;
          while (newPack.length < targetSize) {
            const fallbackRarity = distribution.length > 0 ? distribution[0].rarity : 'rare';
            const fallback = getPackCard(fallbackRarity);
            if (!fallback) break;
            newPack.push({ ...fallback, slot: slot++, isHolo: true, isGodPack: true });
          }

          // Shuffle slightly so the sequence isn't always identical
          newPack.sort(() => rand() - 0.5);
          newPack.forEach((c, i) => c.slot = i);
        } else {
          // Normal pack: use config structure
          let slotIndex = 0;
          
          for (const slotConfig of packStructure.slots) {
            const count = slotConfig.count || 1;
            
            if (slotConfig.type === 'guaranteed') {
              // Guaranteed rarity cards
              for (let i = 0; i < count; i++) {
                const card = getPackCard(slotConfig.rarity);
                if (card) newPack.push({ ...card, slot: slotIndex++ });
              }
            } else if (slotConfig.type === 'weighted' || slotConfig.type === 'rare-slot') {
              // Weighted rarity slot
              for (let i = 0; i < count; i++) {
                if (packToOpen.forceRarity) {
                  // Guaranteed rarity from sealed product
                  const guaranteedCard = getPackCard(packToOpen.forceRarity);
                  if (guaranteedCard) newPack.push({ ...guaranteedCard, slot: slotIndex++ });
                } else {
                  const card = getPackRareSlotCard();
                  if (card) {
                    // Check if this slot has a holo chance (for SP-style rare slots)
                    const isHolo = slotConfig.holoChance && rand() < slotConfig.holoChance;
                    newPack.push({ ...card, slot: slotIndex++, isHolo });
                  }
                }
              }
            } else if (slotConfig.type === 'holo') {
              // Holo slot - always holo
              for (let i = 0; i < count; i++) {
                const foilCard = getPackFoilSlotCard();
                if (foilCard) newPack.push({ ...foilCard, slot: slotIndex++, isHolo: true, isFoilSlot: true });
              }
            }
          }
        }

        // Record milestone events
        if (isGodPack) {
          appendEvent({
            id: `gp-${gameDay || 1}-${packCount + 1}-${Math.floor(rand() * 1e9)}`,
            type: 'godpack',
            game: packGameId,
            set: packSetId,
            day: gameDay || 1,
            packIndex: packCount + 1,
            cards: newPack.map(c => ({ id: c.id, rarity: c.rarity, isHolo: !!c.isHolo, holoMult: c.holoMult || null }))
          });
        }

        // Preload all images in the pack for instant display
        newPack.forEach(card => {
          const img = new Image();
          img.src = card.image;
        });

        // Update state
        setPackInventory(newInventory);
        savePackInventory(newInventory);
        setPackCards(newPack);
        setRevealedCards([]);
        setAllRevealed(false);
        setView('opening');
        const newCount = packCount + 1;
        setPackCount(newCount);
        savePackCount(newCount);
        
        // Reset pack ripping state
        setPackPhase('sealed');
        setRipProgress(0);
        setIsRipping(false);
        setCurrentCardIndex(0);
        setSlidingCards([]);
        setIsPeeking(false);

        // Persist deterministic RNG state after opening a pack (debug mode only)
        persistRngState();
};

      const revealCard = (index) => {
        if (revealedCards.includes(index)) return;
        const newRevealed = [...revealedCards, index];
        setRevealedCards(newRevealed);
        const card = packCards[index];
        if (card) {
          const newCollection = { ...collection };
          const entry = newCollection[card.id] || { normal: 0, holo: 0 };
          if (card.isHolo) entry.holo += 1;
          else entry.normal += 1;
          newCollection[card.id] = entry;
          setCollection(newCollection);
          saveCollection(newCollection);
        }
        if (newRevealed.length === packCards.length) setAllRevealed(true);
      };

      const revealAll = () => {
        const newCollection = { ...collection };
        packCards.forEach((card, index) => {
          if (!revealedCards.includes(index)) {
            const entry = newCollection[card.id] || { normal: 0, holo: 0 };
            if (card.isHolo) entry.holo += 1;
            else entry.normal += 1;
            newCollection[card.id] = entry;
          }
        });
        setRevealedCards(packCards.map((_, i) => i));
        setCollection(newCollection);
        saveCollection(newCollection);
        setAllRevealed(true);
        setPackPhase('revealed');
      };

      // Pack ripping handlers
      const handleRipStart = (e) => {
        if (packPhase !== 'sealed') return;
        e.preventDefault();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        setIsRipping(true);
        setRipStartX(clientX);
      };

      const handleRipMove = (e) => {
        if (!isRipping || packPhase !== 'sealed') return;
        e.preventDefault();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const delta = clientX - ripStartX;
        const progress = Math.max(0, Math.min(100, (delta / 200) * 100));
        setRipProgress(progress);
        
        if (progress >= 100) {
          setIsRipping(false);
          setPackPhase('ripping');
          // After tear animation, transition to stack
          setTimeout(() => {
            setPackPhase('stack');
          }, 400);
        }
      };

      const handleRipEnd = () => {
        if (packPhase !== 'sealed') return;
        setIsRipping(false);
        // If didn't complete, reset progress
        if (ripProgress < 100) {
          setRipProgress(0);
        }
      };

      // Card stack handlers
      const slideCardAway = () => {
        if (packPhase !== 'stack' || currentCardIndex >= packCards.length) return;
        
        // Add current card to sliding animation
        setSlidingCards(prev => [...prev, currentCardIndex]);
        
        // Add card to collection
        const card = packCards[currentCardIndex];
        if (card) {
          const newCollection = { ...collection };
          const entry = newCollection[card.id] || { normal: 0, holo: 0 };
          if (card.isHolo) entry.holo += 1;
          else entry.normal += 1;
          newCollection[card.id] = entry;
          setCollection(newCollection);
          saveCollection(newCollection);
          setRevealedCards(prev => [...prev, currentCardIndex]);
        }
        
        // Move to next card after animation
        setTimeout(() => {
          const nextIndex = currentCardIndex + 1;
          setCurrentCardIndex(nextIndex);
          
          if (nextIndex >= packCards.length) {
            setAllRevealed(true);
            setPackPhase('revealed');
          }
        }, 350);
      };

      const revealAllCards = () => {
        // Add all remaining cards to collection at once
        const newCollection = { ...collection };
        packCards.forEach((card, index) => {
          if (!revealedCards.includes(index)) {
            const entry = newCollection[card.id] || { normal: 0, holo: 0 };
            if (card.isHolo) entry.holo += 1;
            else entry.normal += 1;
            newCollection[card.id] = entry;
          }
        });
        setRevealedCards(packCards.map((_, i) => i));
        setCollection(newCollection);
        saveCollection(newCollection);
        setAllRevealed(true);
        setPackPhase('revealed');
        setCurrentCardIndex(packCards.length);
      };

      const getCollectionStats = () => {
        const totalCards = ALL_CARDS.length;
        const uniqueOwned = Object.entries(collection).filter(([_, e]) => ((e?.normal || 0) + (e?.holo || 0)) > 0).length;
        const uniqueNormalOwned = Object.entries(collection).filter(([_, e]) => (e?.normal || 0) > 0).length;
        const uniqueHoloOwned = Object.entries(collection).filter(([_, e]) => (e?.holo || 0) > 0).length;
        const totalOwned = Object.values(collection).reduce((sum, e) => sum + (e?.normal || 0) + (e?.holo || 0), 0);
        const byRarity = {};
        for (const rarity of RARITY_ORDER) {
          const rarityCards = CARDS_BY_RARITY[rarity] || [];
          const owned = rarityCards.filter(c => {
            const e = collection[c.id];
            return e && ((e.normal || 0) + (e.holo || 0)) > 0;
          }).length;
          byRarity[rarity] = { owned, total: rarityCards.length };
        }
        return { uniqueOwned, uniqueNormalOwned, uniqueHoloOwned, totalCards, totalOwned, byRarity };
      };

      const SELL_TO_SHOP_RATE = 0.60;

      const sellNormalCard = (cardId) => {
        const entry = collection[cardId];
        if (!entry || (entry.normal || 0) === 0) return;

        const marketValue = getBaseMarketValue(cardId);
        const newCollection = { ...collection };
        const nextEntry = { ...(newCollection[cardId] || { normal: 0, holo: 0 }) };
        nextEntry.normal = Math.max(0, (nextEntry.normal || 0) - 1);
        if ((nextEntry.normal || 0) + (nextEntry.holo || 0) === 0) delete newCollection[cardId];
        else newCollection[cardId] = nextEntry;

        const newRations = rations + (marketValue * SELL_TO_SHOP_RATE);

        setCollection(newCollection);
        setRations(newRations);
        saveCollection(newCollection);
        saveRations(newRations);
        setSellConfirm(null);
      };

      const sellHoloCard = (cardId) => {
        const entry = collection[cardId];
        if (!entry || (entry.holo || 0) === 0) return;

        const marketValue = getHoloMarketValue(cardId);
        const newCollection = { ...collection };
        const nextEntry = { ...(newCollection[cardId] || { normal: 0, holo: 0 }) };
        nextEntry.holo = Math.max(0, (nextEntry.holo || 0) - 1);
        if ((nextEntry.normal || 0) + (nextEntry.holo || 0) === 0) delete newCollection[cardId];
        else newCollection[cardId] = nextEntry;

        const newRations = rations + (marketValue * SELL_TO_SHOP_RATE);

        setCollection(newCollection);
        setRations(newRations);
        saveCollection(newCollection);
        saveRations(newRations);
        setSellConfirm(null);
      };


      // Sealed selling (75% of sealed market value)
      const SEALED_SELL_RATE = 0.75;

      const sellSealedSinglePack = () => {
        const price = (sealedMarket && sealedMarket.prices && Number.isFinite(sealedMarket.prices.single)) ? sealedMarket.prices.single : 10;
        const payout = parseFloat((price * SEALED_SELL_RATE).toFixed(2));

        const idx = (packInventory || []).findIndex(p => p && p.type === 'single');
        if (idx === -1) return;

        const newInventory = [...packInventory];
        newInventory.splice(idx, 1);

        const newRations = parseFloat((rations + payout).toFixed(2));
        setPackInventory(newInventory);
        savePackInventory(newInventory);
        setRations(newRations);
        saveRations(newRations);
      };

      // Universal sell sealed product function
      const sellSealedProduct = (gameId, setId, productType) => {
        if (!gameId || !setId || !productType) return;
        
        const count = getSealedCount(gameId, setId, productType);
        if (count <= 0) return;
        
        // Get price for this product
        const price = getProductPrice(gameId, setId, productType);
        const payout = parseFloat((price * SEALED_SELL_RATE).toFixed(2));
        
        // Decrement inventory
        updateSealedCount(gameId, setId, productType, -1);
        
        // Add rations
        const newRations = parseFloat((rations + payout).toFixed(2));
        setRations(newRations);
        saveRations(newRations);
      };

      // Sell a single pack from pack inventory
      const sellSinglePack = (packId) => {
        const packIndex = packInventory.findIndex(p => p.id === packId);
        if (packIndex === -1) return;
        
        const pack = packInventory[packIndex];
        const price = getProductPrice(pack.gameId || currentGameId, pack.setId || currentSetId, 'single');
        const payout = parseFloat((price * SEALED_SELL_RATE).toFixed(2));
        
        // Remove pack from inventory
        const newInventory = [...packInventory];
        newInventory.splice(packIndex, 1);
        setPackInventory(newInventory);
        savePackInventory(newInventory);
        
        // Add rations
        const newRations = parseFloat((rations + payout).toFixed(2));
        setRations(newRations);
        saveRations(newRations);
      };

      // Legacy function - kept for compatibility
      const sellSealedItem = (sealedType) => {
        if (!sealedType) return;
        
        if (sealedType === 'single') {
          // Find first single pack and sell it
          const singlePack = packInventory.find(p => p.type === 'single');
          if (singlePack) {
            sellSinglePack(singlePack.id);
          }
          return;
        }
        
        // For other types, sell from current game/set
        sellSealedProduct(currentGameId, currentSetId, sealedType);
      };

      const getCollectionCards = () => {
        // Collect cards from all games/sets or filtered game/set
        let cards = [];
        
        const gamesToInclude = collectionGameFilter === 'all' 
          ? gamesIndex.games.filter(g => g.enabled).map(g => g.id)
          : [collectionGameFilter];
        
        gamesToInclude.forEach(gameId => {
          const gameConfig = gameConfigs[gameId];
          if (!gameConfig) return;
          
          const setsToInclude = collectionSetFilter === 'all'
            ? gameConfig.sets
            : [collectionSetFilter];
          
          setsToInclude.forEach(setId => {
            const setConfig = setConfigs[gameId]?.[setId];
            if (!setConfig || !setConfig.cards) return;
            
            setConfig.cards.forEach(card => {
              cards.push({
                ...card,
                gameId,
                setId,
                gameName: gameConfig.name,
                setName: setConfig.name
              });
            });
          });
        });

        // Rarity filter (quick buttons)
        if (collectionFilter !== 'all') {
          cards = cards.filter(c => c.rarity === collectionFilter);
        }

        // Search filter (name)
        const q = (collectionSearch || '').trim().toLowerCase();
        if (q) {
          cards = cards.filter(c => (c.name || '').toLowerCase().includes(q));
        }

        // Enrich with ownership + market data
        let enriched = cards.map(card => {
          const entry = collection[card.id] || { normal: 0, holo: 0 };
          const ownedNormal = entry.normal || 0;
          const ownedHolo = entry.holo || 0;
          const owned = ownedNormal + ownedHolo;

          const marketValue = marketValues[card.id] || 1;
          const holoMult = getHoloMultiplier(card.id);
          const holoValue = marketValue * holoMult;

          const history = priceHistory[card.id] || [];
          let priceChange = 0;
          if (history.length >= 2) {
            const prev = history[history.length - 2].value || 1;
            const curr = history[history.length - 1].value || marketValue;
            priceChange = prev ? ((curr - prev) / prev) * 100 : 0;
          }

          return {
            ...card,
            image: buildImageUrl(card.gameId, card.setId, card),
            owned,
            ownedNormal,
            ownedHolo,
            marketValue,
            holoMult,
            holoValue,
            priceChange
          };
        });

        // Owned / unowned / hide unknown filters
        if (hideUnknown) {
          enriched = enriched.filter(c => c.owned > 0);
        }

        if (ownedFilter === 'owned') {
          enriched = enriched.filter(c => c.owned > 0);
        } else if (ownedFilter === 'unowned') {
          enriched = enriched.filter(c => c.owned === 0);
        }

        if (holoFilter === 'hasHolo') {
          enriched = enriched.filter(c => c.ownedHolo > 0);
        } else if (holoFilter === 'noHolo') {
          enriched = enriched.filter(c => c.ownedHolo === 0);
        }

        const dir = sortDir === 'asc' ? 1 : -1;
        const rarityIndex = (r) => {
          const i = RARITY_ORDER.indexOf(r);
          return i === -1 ? 999 : i;
        };

        enriched.sort((a, b) => {
          // Always keep things stable by breaking ties on name
          const tieByName = () => a.name.localeCompare(b.name);

          switch (sortKey) {
            case 'name':
              return a.name.localeCompare(b.name) * dir;
            case 'rarity': {
              const d = (rarityIndex(a.rarity) - rarityIndex(b.rarity)) * dir;
              return d !== 0 ? d : tieByName();
            }
            case 'value': {
              const d = (a.marketValue - b.marketValue) * dir;
              return d !== 0 ? d : tieByName();
            }
            case 'holoValue': {
              const d = (a.holoValue - b.holoValue) * dir;
              return d !== 0 ? d : tieByName();
            }
            case 'change': {
              const d = (a.priceChange - b.priceChange) * dir;
              return d !== 0 ? d : tieByName();
            }
            case 'holoMult': {
              const d = (a.holoMult - b.holoMult) * dir;
              return d !== 0 ? d : tieByName();
            }
            case 'owned':
            default: {
              const d = (a.owned - b.owned) * dir;
              // If owned counts are tied, keep owned cards above unknown by default
              if (d !== 0) return d;
              const d2 = (a.owned > 0 ? -1 : 1) - (b.owned > 0 ? -1 : 1);
              return d2 !== 0 ? d2 : tieByName();
            }
          }
        });

        return enriched;
      };

      
      
      const getShopSellCards = () => {
        // Build cards from all games/sets (or filtered) with ownership + values
        let cards = [];
        
        const gamesToInclude = sellGameFilter === 'all' 
          ? gamesIndex.games.filter(g => g.enabled).map(g => g.id)
          : [sellGameFilter];
        
        gamesToInclude.forEach(gameId => {
          const gameConfig = gameConfigs[gameId];
          if (!gameConfig) return;
          
          const setsToInclude = sellSetFilter === 'all'
            ? gameConfig.sets
            : [sellSetFilter];
          
          setsToInclude.forEach(setId => {
            const setConfig = setConfigs[gameId]?.[setId];
            if (!setConfig || !setConfig.cards) return;
            
            setConfig.cards.forEach(card => {
              const entry = collection[card.id] || { normal: 0, holo: 0 };
              const ownedNormal = entry.normal || 0;
              const ownedHolo = entry.holo || 0;
              const owned = ownedNormal + ownedHolo;
              const marketValue = getBaseMarketValue(card.id);
              const holoValue = getHoloMarketValue(card.id);
              const payout = marketValue * SELL_TO_SHOP_RATE;
              const holoPayout = holoValue * SELL_TO_SHOP_RATE;
              
              cards.push({
                ...card,
                gameId,
                setId,
                gameName: gameConfig.name,
                setName: setConfig.name,
                image: buildImageUrl(gameId, setId, card),
                owned,
                ownedNormal,
                ownedHolo,
                marketValue,
                holoValue,
                payout,
                holoPayout
              });
            });
          });
        });

        // Variant filter
        if (shopSellVariant === 'normal') cards = cards.filter(c => c.ownedNormal > 0);
        else if (shopSellVariant === 'holo') cards = cards.filter(c => c.ownedHolo > 0);
        else cards = cards.filter(c => c.owned > 0);

        // Rarity filter
        if (shopSellFilter !== 'all') {
          cards = cards.filter(c => c.rarity === shopSellFilter);
        }

        // Search filter
        const q = (shopSellSearch || '').trim().toLowerCase();
        if (q) {
          cards = cards.filter(c => (c.name || '').toLowerCase().includes(q));
        }

        const rarityRank = (r) => {
          const idx = RARITY_ORDER.indexOf(r);
          return idx === -1 ? 999 : idx;
        };

        // Sort
        cards.sort((a, b) => {
          if (shopSellSort === 'name') return (a.name || '').localeCompare(b.name || '');
          if (shopSellSort === 'rarity') return rarityRank(a.rarity) - rarityRank(b.rarity);
          if (shopSellSort === 'owned') return b.owned - a.owned;

          // payout (default): sort by best available payout given current variant filter
          const ap = shopSellVariant === 'holo' ? a.holoPayout : shopSellVariant === 'normal' ? a.payout : Math.max(a.payout, a.holoPayout);
          const bp = shopSellVariant === 'holo' ? b.holoPayout : shopSellVariant === 'normal' ? b.payout : Math.max(b.payout, b.holoPayout);
          return bp - ap;
        });

        return cards;
      };


const movers7d = useMemo(() => {
        const fromDay = Math.max(1, (gameDay || 1) - 7);
        const result = {};
        
        if (!marketValues || !priceHistory) return { fromDay, byGameSet: {} };

        // Calculate movers for each game/set
        for (const [gameId, gameSets] of Object.entries(setConfigs)) {
          const gameConfig = gameConfigs[gameId];
          if (!gameConfig) continue;
          
          for (const [setId, setConfig] of Object.entries(gameSets)) {
            if (!setConfig || !setConfig.cards) continue;
            
            const changes = [];
            
            for (const card of setConfig.cards) {
              const arr = priceHistory[card.id];
              const curVal = marketValues[card.id];

              if (curVal === undefined || curVal === null) continue;

              let oldVal = null;
              if (Array.isArray(arr) && arr.length) {
                let candidate = arr[0];
                for (let j = 0; j < arr.length; j++) {
                  const e = arr[j];
                  if (!e || typeof e.value !== 'number') continue;
                  if (typeof e.day === 'number' && e.day <= fromDay) candidate = e;
                  if (typeof e.day === 'number' && e.day === fromDay) { candidate = e; break; }
                }
                oldVal = candidate && typeof candidate.value === 'number' ? candidate.value : null;
              }

              if (oldVal === null || oldVal <= 0) continue;

              const pct = ((curVal - oldVal) / oldVal) * 100;
              changes.push({ 
                card: { ...card, gameId, setId }, 
                pct, 
                curVal, 
                oldVal 
              });
            }

            const gainers = changes.slice().sort((a, b) => b.pct - a.pct).slice(0, 5);
            const losers = changes.slice().sort((a, b) => a.pct - b.pct).slice(0, 5);

            if (!result[gameId]) result[gameId] = {};
            result[gameId][setId] = {
              gameName: gameConfig.name,
              setName: setConfig.name,
              gainers,
              losers
            };
          }
        }

        return { fromDay, byGameSet: result };
      }, [priceHistory, marketValues, gameDay, setConfigs, gameConfigs]);

      const totalCollectionValue = useMemo(() => {
        let sum = 0;
        const entries = Object.entries(collection || {});
        for (let i = 0; i < entries.length; i++) {
          const cardId = entries[i][0];
          const entry = entries[i][1] || {};
          const normal = (typeof entry.normal === 'number') ? entry.normal : 0;
          const holo = (typeof entry.holo === 'number') ? entry.holo : 0;
          const base = getBaseMarketValue(cardId);
          if (normal > 0) sum += normal * base;
          if (holo > 0) sum += holo * getHoloMarketValue(cardId);
        }
        return parseFloat(sum.toFixed(2));
      }, [collection, marketValues, holoMultipliers]);

if (!isLoaded) {
        return (
          <div style={{ minHeight: '100vh', background: '#111827', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>

            {/* God Pack screen effect */}
            {godPackActive && (
              <div className="godpack-effect">
                {godPackConfetti.map((p, i) => (
                  <div
                    key={i}
                    className="confetti-piece"
                    style={{
                      '--left': p.left,
                      '--dur': p.dur,
                      '--delay': p.delay,
                      '--w': p.w,
                      '--h': p.h,
                      '--c': p.c
                    }}
                  />
                ))}
              </div>
            )}
            <div style={{ textAlign: 'center', color: 'white' }}>
              <div style={{ width: 64, height: 64, border: '4px solid #a855f7', borderTopColor: 'transparent', borderRadius: '50%', animation: 'spin 1s linear infinite', margin: '0 auto 16px' }}></div>
              <p style={{ fontSize: 20 }}>Loading...</p>
            </div>
          </div>
        );
      }

      const stats = getCollectionStats();      return (
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #111827 0%, #2e1065 50%, #111827 100%)' }}>
          {/* God Pack screen effect */}
          {godPackActive && (
            <div className="godpack-effect">
              {godPackConfetti.map((p, i) => (
                <div
                  key={i}
                  className="confetti-piece"
                  style={{
                    '--left': p.left,
                    '--dur': p.dur,
                    '--delay': p.delay,
                    '--w': p.w,
                    '--h': p.h,
                    '--c': p.c
                  }}
                />
              ))}
            </div>
          )}

          {/* God Pack confirmation gate */}
          {showGodPackGate && (
            <div className="godpack-gate">
              <div className="godpack-gate-card" onClick={(e) => e.stopPropagation()}>
                <div className="godpack-gate-content">
                  <div className="godpack-gate-title">GOD PACK</div>
                  <div className="godpack-gate-sub">All {currentSetConfig.godPack?.size || currentSetConfig.packStructure?.size || 8} cards in this pack are holo.</div>
                  <div className="godpack-gate-note">Tap continue to start the reveal.</div>
                  <div className="godpack-gate-actions">
                    <button className="btn btn-primary" onClick={dismissGodPackGate}>Continue</button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Milestone/Event details */}
          {selectedEvent && (
            <div className="modal-overlay" onClick={closeEventDetails}>
              <div className="modal" onClick={(e) => e.stopPropagation()} style={{ maxWidth: 760 }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 12 }}>
                  <h3 style={{ margin: 0 }}>{getEventLabel(selectedEvent)} · Day {selectedEvent.day || 1}</h3>
                  <button className="btn btn-ghost" onClick={closeEventDetails}>Close</button>
                </div>
                <div style={{ marginTop: 10, color: 'rgba(255,255,255,0.85)' }}>
                  {formatEventSummary(selectedEvent)}
                </div>
                {selectedEvent.type === 'godpack' && Array.isArray(selectedEvent.cards) && (
                  <div style={{ marginTop: 14, display: 'grid', gridTemplateColumns: `repeat(${Math.min(4, selectedEvent.cards.length)}, minmax(0, 1fr))`, gap: 10 }}>
                    {selectedEvent.cards.map((c, idx) => {
                      const card = getCardById(c.id);
                      if (!card) return <div key={idx} style={{ height: 90, borderRadius: 8, background: 'rgba(255,255,255,0.06)' }} />;
                      return (
                        <div key={idx} style={{ position: 'relative', borderRadius: 10, overflow: 'hidden' }}>
                          <img src={card.image} alt={card.name} style={{ width: '100%', display: 'block' }} />
                          <div className="holo-overlay" style={{ position: 'absolute', inset: 0, pointerEvents: 'none' }} />
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            </div>
          )}

          <header style={{ background: 'rgba(0,0,0,0.4)', borderBottom: '1px solid rgba(168,85,247,0.3)', padding: '12px 16px', position: 'sticky', top: 0, zIndex: 50 }} className="topbar">
            <div style={{ maxWidth: 1200, margin: '0 auto', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }} className="topbar-inner">
              <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                <h1 className="topbar-title" style={{ fontSize: 24, fontWeight: 'bold', background: 'linear-gradient(90deg, #a855f7, #ec4899)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', margin: 0 }}>
                  TCG Market Sim
                </h1>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: 16, flexWrap: 'wrap', justifyContent: 'flex-end' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '6px 12px', background: 'rgba(168,85,247,0.2)', borderRadius: 8, border: '1px solid rgba(168,85,247,0.4)' }}>
                  <img src="./rations.png" alt="Rations" style={{ width: 24, height: 24 }} />
                  <span style={{ color: '#fbbf24', fontSize: 18, fontWeight: 'bold' }}>{rations.toFixed(2)}</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, padding: '10px 14px', background: 'rgba(0,0,0,0.25)', borderRadius: 8, border: '1px solid rgba(168,85,247,0.25)' }}>
                    <span style={{ color: '#e5e7eb', fontSize: 14 }}>Day</span>
                    <span style={{ color: 'white', fontSize: 16, fontWeight: 'bold' }}>{gameDay}</span>
                  </div>
                  <button onClick={advanceDay} style={{ padding: '10px 14px', borderRadius: 8, border: '1px solid rgba(255,255,255,0.12)', background: 'rgba(34,197,94,0.20)', color: 'white', cursor: 'pointer', fontWeight: 'bold' }}>
                    Advance Day
                  </button>
                </div>
                <nav className="topbar-nav" style={{ display: 'flex', gap: 8 }}>
                <button onClick={() => navigate('home')} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: view === 'home' || view === 'opening' ? '#9333ea' : 'rgba(107,114,128,0.5)', color: 'white', fontSize: 14 }}>
                  Inventory
                </button>
                <button onClick={() => navigate('shop')} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: view === 'shop' ? '#9333ea' : 'rgba(107,114,128,0.5)', color: 'white', fontSize: 14 }}>
                  Shop
                </button>
                <button onClick={() => navigate('market')} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: view === 'market' ? '#9333ea' : 'rgba(107,114,128,0.5)', color: 'white', fontSize: 14 }}>
                  Market
                </button>
                <button onClick={() => navigate('collection')} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: view === 'collection' ? '#9333ea' : 'rgba(107,114,128,0.5)', color: 'white', fontSize: 14 }}>
                  Collection
                </button>
                <button onClick={() => navigate('settings')} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: view === 'settings' ? '#9333ea' : 'rgba(107,114,128,0.5)', color: 'white', fontSize: 14 }}>
                  Settings
                </button>
              </nav>

              <button
                className="hamburger-btn"
                onClick={() => setMenuOpen(v => !v)}
                aria-label="Menu"
                style={{
                  padding: '8px 12px',
                  borderRadius: 10,
                  border: '1px solid rgba(255,255,255,0.12)',
                  background: 'rgba(0,0,0,0.25)',
                  color: 'white',
                  cursor: 'pointer',
                  fontWeight: 900,
                  fontSize: 18,
                  lineHeight: 1
                }}
              >
                ☰
              </button>

              {menuOpen && (
                <div style={{ display: 'contents' }}>
                  <div className="menu-overlay" onClick={() => setMenuOpen(false)} />
                  <div className="menu-panel" role="menu" aria-label="Navigation menu">
                    <button
                      className="menu-item"
                      onClick={() => navigate('home')}
                      style={{
                        width: '100%',
                        padding: '12px 14px',
                        borderRadius: 12,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: view === 'home' || view === 'opening' ? 'rgba(147,51,234,0.35)' : 'rgba(17,24,39,0.85)',
                        color: 'white',
                        cursor: 'pointer',
                        textAlign: 'left',
                        fontWeight: 700,
                        marginBottom: 8
                      }}
                    >
                      Inventory
                    </button>
                    <button
                      className="menu-item"
                      onClick={() => navigate('shop')}
                      style={{
                        width: '100%',
                        padding: '12px 14px',
                        borderRadius: 12,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: view === 'shop' ? 'rgba(147,51,234,0.35)' : 'rgba(17,24,39,0.85)',
                        color: 'white',
                        cursor: 'pointer',
                        textAlign: 'left',
                        fontWeight: 700,
                        marginBottom: 8
                      }}
                    >
                      Shop
                    </button>
                    <button
                      className="menu-item"
                      onClick={() => navigate('market')}
                      style={{
                        width: '100%',
                        padding: '12px 14px',
                        borderRadius: 12,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: view === 'market' ? 'rgba(147,51,234,0.35)' : 'rgba(0,0,0,0.2)',
                        color: 'white',
                        fontSize: 15,
                        textAlign: 'left',
                        cursor: 'pointer'
                      }}
                    >
                      Market
                    </button>
                    <button
                      className="menu-item"
                      onClick={() => navigate('collection')}
                      style={{
                        width: '100%',
                        padding: '12px 14px',
                        borderRadius: 12,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: view === 'collection' ? 'rgba(147,51,234,0.35)' : 'rgba(17,24,39,0.85)',
                        color: 'white',
                        cursor: 'pointer',
                        textAlign: 'left',
                        fontWeight: 700,
                        marginBottom: 8
                      }}
                    >
                      Collection
                      <span style={{ display: 'block', marginTop: 4, color: 'rgba(255,255,255,0.75)', fontWeight: 600, fontSize: 12 }}>
                        N {stats.uniqueNormalOwned}/{stats.totalCards} • H {stats.uniqueHoloOwned}/{stats.totalCards}
                      </span>
                    </button>
                    <button
                      className="menu-item"
                      onClick={() => navigate('settings')}
                      style={{
                        width: '100%',
                        padding: '12px 14px',
                        borderRadius: 12,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: view === 'settings' ? 'rgba(147,51,234,0.35)' : 'rgba(17,24,39,0.85)',
                        color: 'white',
                        cursor: 'pointer',
                        textAlign: 'left',
                        fontWeight: 700
                      }}
                    >
                      Settings
                    </button>
                  </div>
                </div>
              )}

              </div>
            </div>
          </header>

          <main style={{ maxWidth: 1200, margin: '0 auto', padding: 32 }}>
            {view === 'home' && (
              <div>
                <h2 style={{ color: 'white', fontSize: 28, fontWeight: 'bold', marginBottom: 24, textAlign: 'center' }}>
                  Inventory
                </h2>

                {/* All owned inventory grouped by game then set */}
                {(() => {
                  // Collect all owned items
                  const ownedByGame = {};
                  
                  // Add single packs from packInventory
                  packInventory.forEach(pack => {
                    const gameId = pack.gameId || 'tta';
                    const setId = pack.setId || 'base-set';
                    if (!ownedByGame[gameId]) ownedByGame[gameId] = {};
                    if (!ownedByGame[gameId][setId]) ownedByGame[gameId][setId] = { packs: [], sealed: {} };
                    ownedByGame[gameId][setId].packs.push(pack);
                  });
                  
                  // Add sealed products
                  Object.entries(sealedInventory).forEach(([gameId, sets]) => {
                    Object.entries(sets).forEach(([setId, products]) => {
                      Object.entries(products).forEach(([productType, count]) => {
                        if (count > 0) {
                          if (!ownedByGame[gameId]) ownedByGame[gameId] = {};
                          if (!ownedByGame[gameId][setId]) ownedByGame[gameId][setId] = { packs: [], sealed: {} };
                          ownedByGame[gameId][setId].sealed[productType] = count;
                        }
                      });
                    });
                  });
                  
                  const hasAnyInventory = Object.keys(ownedByGame).length > 0;
                  
                  if (!hasAnyInventory) {
                    return (
                      <div style={{ textAlign: 'center', padding: 40 }}>
                        <p style={{ color: '#9ca3af', fontSize: 18, marginBottom: 20 }}>Your inventory is empty</p>
                        <button 
                          onClick={() => navigate('shop')}
                          style={{
                            padding: '12px 24px',
                            background: 'linear-gradient(90deg, #9333ea, #ec4899)',
                            color: 'white',
                            border: 'none',
                            borderRadius: 8,
                            cursor: 'pointer',
                            fontSize: 16,
                            fontWeight: 'bold'
                          }}
                        >
                          Visit Shop
                        </button>
                      </div>
                    );
                  }
                  
                  return Object.entries(ownedByGame).map(([gameId, sets]) => {
                    const gameConfig = gameConfigs[gameId];
                    const gameName = gameConfig?.name || gameId;
                    
                    return (
                      <div key={gameId} style={{ marginBottom: 32 }}>
                        <h3 style={{ 
                          color: '#a855f7', 
                          fontSize: 20, 
                          fontWeight: 'bold', 
                          margin: '0 0 16px',
                          padding: '8px 0',
                          borderBottom: '2px solid rgba(168,85,247,0.3)'
                        }}>
                          {gameName}
                        </h3>
                        
                        {Object.entries(sets).map(([setId, inventory]) => {
                          const setConfig = setConfigs[gameId]?.[setId];
                          const setName = setConfig?.name || setId;
                          const cardbackUrl = `${GITHUB_BASE}/${gameConfig?.cardback || 'cardback.png'}`;
                          const packImageUrl = buildProductImageUrl(gameId, setId, 'single');
                          
                          const totalPacks = inventory.packs.length;
                          const sealedItems = Object.entries(inventory.sealed);
                          
                          return (
                            <div key={setId} style={{ marginBottom: 20, padding: 16, background: 'rgba(0,0,0,0.2)', borderRadius: 12 }}>
                              <h4 style={{ color: '#d1d5db', fontSize: 16, fontWeight: 'bold', margin: '0 0 12px' }}>
                                {setName}
                              </h4>
                              
                              <div style={{ display: 'flex', flexWrap: 'wrap', gap: 12 }}>
                                {/* Single Packs */}
                                {totalPacks > 0 && (
                                  <div 
                                    onClick={() => setInspectProduct({ 
                                      type: 'packs', 
                                      gameId, 
                                      setId, 
                                      gameName, 
                                      setName,
                                      count: totalPacks,
                                      packs: inventory.packs,
                                      productImageUrl: packImageUrl,
                                      cardbackUrl
                                    })}
                                    style={{ 
                                      padding: 12, 
                                      background: 'rgba(168,85,247,0.15)', 
                                      borderRadius: 10, 
                                      border: '2px solid rgba(168,85,247,0.4)',
                                      cursor: 'pointer',
                                      textAlign: 'center',
                                      minWidth: 100,
                                      transition: 'transform 0.2s'
                                    }}
                                    onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                    onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}
                                  >
                                    <img src={packImageUrl} alt="Packs" style={{ width: 60, height: 90, objectFit: 'cover', borderRadius: 6, marginBottom: 8 }} onError={(e) => e.target.src = cardbackUrl} />
                                    <div style={{ color: 'white', fontWeight: 'bold', fontSize: 14 }}>Packs</div>
                                    <div style={{ color: '#a855f7', fontWeight: 'bold', fontSize: 18 }}>×{totalPacks}</div>
                                  </div>
                                )}
                                
                                {/* Sealed Products */}
                                {sealedItems.map(([productType, count]) => {
                                  const productConfig = setConfig?.sealedProducts?.[productType];
                                  const productName = productConfig?.name || productType;
                                  const productImageUrl = buildProductImageUrl(gameId, setId, productType);
                                  
                                  return (
                                    <div 
                                      key={productType}
                                      onClick={() => setInspectProduct({ 
                                        type: 'sealed', 
                                        productType,
                                        gameId, 
                                        setId, 
                                        gameName, 
                                        setName,
                                        productName,
                                        count,
                                        packs: productConfig?.packs || 1,
                                        guaranteed: productConfig?.guaranteed || [],
                                        productImageUrl,
                                        cardbackUrl
                                      })}
                                      style={{ 
                                        padding: 12, 
                                        background: 'rgba(59,130,246,0.15)', 
                                        borderRadius: 10, 
                                        border: '2px solid rgba(59,130,246,0.4)',
                                        cursor: 'pointer',
                                        textAlign: 'center',
                                        minWidth: 100,
                                        transition: 'transform 0.2s'
                                      }}
                                      onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                      onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}
                                    >
                                      <img src={productImageUrl} alt={productName} style={{ width: 60, height: 90, objectFit: 'cover', borderRadius: 6, marginBottom: 8 }} onError={(e) => e.target.src = cardbackUrl} />
                                      <div style={{ color: 'white', fontWeight: 'bold', fontSize: 14 }}>{productName}</div>
                                      <div style={{ color: '#3b82f6', fontWeight: 'bold', fontSize: 18 }}>×{count}</div>
                                    </div>
                                  );
                                })}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    );
                  });
                })()}
              </div>
            )}
            
            {/* Inspect Product Modal */}
            {inspectProduct && (
              <div
                onClick={() => setInspectProduct(null)}
                style={{
                  position: 'fixed',
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  background: 'rgba(0, 0, 0, 0.85)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  zIndex: 1100,
                  padding: 32
                }}
              >
                <div
                  onClick={(e) => e.stopPropagation()}
                  style={{
                    background: '#111827',
                    border: '2px solid rgba(168,85,247,0.5)',
                    borderRadius: 16,
                    padding: 24,
                    maxWidth: 400,
                    width: '100%',
                    textAlign: 'center'
                  }}
                >
                  <img 
                    src={inspectProduct.productImageUrl || inspectProduct.cardbackUrl} 
                    alt="Product" 
                    style={{ width: 120, height: 180, objectFit: 'cover', borderRadius: 10, marginBottom: 16 }} 
                    onError={(e) => e.target.src = inspectProduct.cardbackUrl}
                  />
                  
                  <h3 style={{ color: 'white', fontSize: 20, fontWeight: 'bold', margin: '0 0 4px' }}>
                    {inspectProduct.type === 'packs' ? 'Single Packs' : inspectProduct.productName}
                  </h3>
                  <p style={{ color: '#9ca3af', fontSize: 14, margin: '0 0 12px' }}>
                    {inspectProduct.gameName} • {inspectProduct.setName}
                  </p>
                  <p style={{ color: '#a855f7', fontSize: 24, fontWeight: 'bold', margin: '0 0 8px' }}>
                    ×{inspectProduct.count}
                  </p>
                  
                  {inspectProduct.type === 'sealed' && (
                    <p style={{ color: '#10b981', fontSize: 12, margin: '0 0 16px' }}>
                      Opens into {inspectProduct.packs} pack{inspectProduct.packs > 1 ? 's' : ''}
                      {inspectProduct.guaranteed.length > 0 && (
                        <> • Guaranteed: {inspectProduct.guaranteed.map(g => `${g.count} ${g.rarity}`).join(', ')}</>
                      )}
                    </p>
                  )}
                  
                  {/* Market Value */}
                  <div style={{ background: 'rgba(0,0,0,0.3)', borderRadius: 8, padding: 12, marginBottom: 16 }}>
                    <div style={{ color: '#9ca3af', fontSize: 12, marginBottom: 4 }}>Market Value</div>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 6 }}>
                      <img src="./rations.png" alt="" style={{ width: 20, height: 20 }} />
                      <span style={{ color: '#fbbf24', fontSize: 20, fontWeight: 'bold' }}>
                        {getProductPrice(inspectProduct.gameId, inspectProduct.setId, inspectProduct.type === 'packs' ? 'single' : inspectProduct.productType).toFixed(2)}
                      </span>
                      <span style={{ color: '#9ca3af', fontSize: 12 }}>each</span>
                    </div>
                  </div>
                  
                  <div style={{ display: 'flex', gap: 12 }}>
                    <button
                      onClick={() => setInspectProduct(null)}
                      style={{
                        flex: 1,
                        padding: '12px',
                        background: '#374151',
                        color: 'white',
                        border: 'none',
                        borderRadius: 8,
                        cursor: 'pointer',
                        fontWeight: 'bold'
                      }}
                    >
                      Close
                    </button>
                    
                    {inspectProduct.type === 'packs' ? (
                      <button
                        onClick={() => {
                          // Open first pack directly using its ID
                          const packToOpen = inspectProduct.packs[0];
                          if (packToOpen) {
                            setInspectProduct(null);
                            openSpecificPack(packToOpen.id);
                          }
                        }}
                        style={{
                          flex: 1,
                          padding: '12px',
                          background: 'linear-gradient(90deg, #9333ea, #ec4899)',
                          color: 'white',
                          border: 'none',
                          borderRadius: 8,
                          cursor: 'pointer',
                          fontWeight: 'bold'
                        }}
                      >
                        Open Pack
                      </button>
                    ) : (
                      <button
                        onClick={() => {
                          openSealedProduct(inspectProduct.gameId, inspectProduct.setId, inspectProduct.productType);
                          if (inspectProduct.count <= 1) {
                            setInspectProduct(null);
                          } else {
                            setInspectProduct({...inspectProduct, count: inspectProduct.count - 1});
                          }
                        }}
                        style={{
                          flex: 1,
                          padding: '12px',
                          background: 'linear-gradient(90deg, #3b82f6, #6366f1)',
                          color: 'white',
                          border: 'none',
                          borderRadius: 8,
                          cursor: 'pointer',
                          fontWeight: 'bold'
                        }}
                      >
                        Rip Open (+{inspectProduct.packs} packs)
                      </button>
                    )}
                  </div>
                  
                  {/* Sell option */}
                  <button
                    onClick={() => {
                      if (inspectProduct.type === 'packs') {
                        sellSinglePack(inspectProduct.packs[0].id);
                      } else {
                        sellSealedProduct(inspectProduct.gameId, inspectProduct.setId, inspectProduct.productType);
                      }
                      if (inspectProduct.count <= 1) {
                        setInspectProduct(null);
                      } else {
                        const newPacks = inspectProduct.type === 'packs' ? inspectProduct.packs.slice(1) : inspectProduct.packs;
                        setInspectProduct({...inspectProduct, count: inspectProduct.count - 1, packs: newPacks});
                      }
                    }}
                    style={{
                      width: '100%',
                      marginTop: 12,
                      padding: '10px',
                      background: 'rgba(239,68,68,0.2)',
                      color: '#f87171',
                      border: '1px solid rgba(239,68,68,0.4)',
                      borderRadius: 8,
                      cursor: 'pointer',
                      fontWeight: 'bold',
                      fontSize: 13
                    }}
                  >
                    Sell for {(getProductPrice(inspectProduct.gameId, inspectProduct.setId, inspectProduct.type === 'packs' ? 'single' : inspectProduct.productType) * SEALED_SELL_RATE).toFixed(2)} Rations
                  </button>
                </div>
              </div>
            )}

            {view === 'shop' && (
              <div>
                <h2 style={{ color: 'white', fontSize: 28, fontWeight: 'bold', marginBottom: 32, textAlign: 'center' }}>
                  Shop
                </h2>

                <div style={{ display: 'flex', justifyContent: 'center', gap: 10, marginBottom: 18, flexWrap: 'wrap' }}>
                  <button
                    onClick={() => setShopTab('buy')}
                    style={{
                      padding: '10px 16px',
                      borderRadius: 999,
                      border: shopTab === 'buy' ? '2px solid rgba(168,85,247,0.75)' : '1px solid rgba(255,255,255,0.12)',
                      background: shopTab === 'buy' ? 'rgba(168,85,247,0.18)' : 'rgba(107,114,128,0.22)',
                      color: 'white',
                      cursor: 'pointer',
                      fontWeight: 800
                    }}
                  >
                    Buy
                  </button>
                  <button
                    onClick={() => setShopTab('sell')}
                    style={{
                      padding: '10px 16px',
                      borderRadius: 999,
                      border: shopTab === 'sell' ? '2px solid rgba(168,85,247,0.75)' : '1px solid rgba(255,255,255,0.12)',
                      background: shopTab === 'sell' ? 'rgba(168,85,247,0.18)' : 'rgba(107,114,128,0.22)',
                      color: 'white',
                      cursor: 'pointer',
                      fontWeight: 800
                    }}
                  >
                    Sell
                  </button>
                </div>

                {shopTab === 'buy' && (
                  <>


                {/* Daily Singles - Price Tier Based */}
                <div style={{ maxWidth: 1200, margin: '0 auto 28px', padding: 16, borderRadius: 16, background: 'rgba(17,24,39,0.55)', border: '1px solid rgba(255,255,255,0.10)' }}>
                  <div style={{ display: 'flex', alignItems: 'baseline', justifyContent: 'space-between', gap: 16, flexWrap: 'wrap', marginBottom: 10 }}>
                    <h3 style={{ color: 'white', fontSize: 20, fontWeight: 'bold', margin: 0 }}>Daily Singles</h3>
                    <div style={{ color: '#9ca3af', fontSize: 12 }}>Rotates daily • 25% markup • {dailyShopDate || ''}</div>
                  </div>
                  <p style={{ color: '#9ca3af', fontSize: 13, margin: '0 0 14px' }}>Cards from any game/set, sorted by price tier. Buy directly — but it costs more than pulling from packs.</p>

                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))', gap: 16 }}>
                    {DAILY_SHOP_TIERS.map(tier => {
                      const pick = dailyShopPicks[tier.key];
                      if (!pick) return null;
                      
                      // Get the card info from the correct game/set
                      const pickSetConfig = setConfigs[pick.gameId]?.[pick.setId];
                      const pickGameConfig = gameConfigs[pick.gameId];
                      const cardData = pickSetConfig?.cards?.find(c => c.id === pick.cardId);
                      if (!cardData) return null;
                      
                      // Build card object with image URL
                      const card = {
                        ...cardData,
                        image: buildImageUrl(pick.gameId, pick.setId, cardData)
                      };
                      
                      const price = getDailyShopPrice(card.id, pick.gameId, pick.setId);
                      const rarityInfo = pickGameConfig?.rarities?.find(r => r.id === card.rarity);
                      const colors = RARITY_COLORS[card.rarity] || { bg: '#374151', border: '#6b7280', text: '#d1d5db' };
                      
                      return (
                        <div key={tier.key} style={{
                          background: 'rgba(31,41,55,0.75)',
                          borderRadius: 14,
                          padding: 12,
                          border: `2px solid ${tier.color}55`,
                          display: 'flex',
                          flexDirection: 'column',
                          gap: 10
                        }}>
                          <div style={{ color: tier.color, fontSize: 11, fontWeight: 'bold', textTransform: 'uppercase', letterSpacing: 1 }}>
                            {tier.label}
                          </div>
                          <div style={{ display: 'flex', gap: 10, alignItems: 'center' }}>
                            <img
                              src={card.image}
                              alt={card.name}
                              style={{ width: 64, height: 96, objectFit: 'cover', borderRadius: 10, border: '1px solid rgba(255,255,255,0.10)', cursor: 'pointer' }}
                              onClick={() => setEnlargedCard(card)}
                            />
                            <div style={{ flex: 1, minWidth: 0 }}>
                              <div style={{ color: 'white', fontWeight: 800, fontSize: 14, marginBottom: 4, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{card.name}</div>
                              <div style={{ color: '#9ca3af', fontSize: 10, marginBottom: 4 }}>{pickGameConfig?.name}</div>
                              <div style={{ display: 'inline-flex', alignItems: 'center', gap: 6, padding: '3px 8px', borderRadius: 999, background: colors.bg, border: `1px solid ${colors.border}` }}>
                                <span style={{ color: colors.text, fontSize: 11, fontWeight: 800, textTransform: 'capitalize' }}>{rarityInfo?.name || card.rarity}</span>
                              </div>
                            </div>
                          </div>

                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 10 }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontWeight: 'bold' }}>
                              <img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />
                              <span style={{ color: '#fbbf24' }}>{price.toFixed(2)}</span>
                            </div>
                            <button
                              onClick={() => setPurchaseConfirm({
                                type: 'dailyCard',
                                title: `Buy ${card.name}`,
                                cost: price,
                                cardId: card.id,
                                dailyCardGameId: pick.gameId,
                                dailyCardSetId: pick.setId,
                                details: `Daily single from ${pickGameConfig?.name} • 25% markup. Adds 1 copy to your collection.`
                              })}
                              disabled={rations < price}
                              style={{
                                padding: '8px 10px',
                                borderRadius: 10,
                                border: 'none',
                                cursor: rations < price ? 'not-allowed' : 'pointer',
                                background: rations < price ? '#374151' : 'linear-gradient(90deg, #3b82f6, #6366f1)',
                                color: 'white',
                                fontWeight: 800,
                                opacity: rations < price ? 0.55 : 1
                              }}
                            >
                              Buy
                            </button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>

                
                {/* All Games/Sets Products */}
                {gamesIndex.games.filter(g => g.enabled).map(game => {
                  const gameConfig = gameConfigs[game.id];
                  if (!gameConfig) return null;
                  
                  return (
                    <div key={game.id} style={{ maxWidth: 1200, margin: '0 auto 32px' }}>
                      <h3 style={{ 
                        color: '#a855f7', 
                        fontSize: 20, 
                        fontWeight: 'bold', 
                        margin: '0 0 16px',
                        padding: '8px 0',
                        borderBottom: '2px solid rgba(168,85,247,0.3)'
                      }}>
                        {game.name}
                      </h3>
                      
                      {gameConfig.sets.map(setId => {
                        const setConfig = setConfigs[game.id]?.[setId];
                        if (!setConfig) return null;
                        
                        const isCurrentSet = game.id === currentGameId && setId === currentSetId;
                        
                        return (
                          <div key={setId} style={{ marginBottom: 24 }}>
                            <h4 style={{ 
                              color: '#d1d5db', 
                              fontSize: 16, 
                              fontWeight: 'bold', 
                              margin: '0 0 12px',
                              display: 'flex',
                              alignItems: 'center',
                              gap: 8
                            }}>
                              {setConfig.name}
                              {isCurrentSet && (
                                <span style={{ 
                                  fontSize: 10, 
                                  padding: '2px 8px', 
                                  background: 'rgba(168,85,247,0.3)', 
                                  borderRadius: 999,
                                  color: '#a855f7'
                                }}>
                                  ACTIVE
                                </span>
                              )}
                            </h4>
                            
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: 16 }}>
                              
                              {/* Free Starter - per game/set */}
                              {(() => {
                                const claimKey = `${game.id}-${setId}`;
                                const isClaimed = freeStartersClaimed[claimKey];
                                const packImageUrl = buildProductImageUrl(game.id, setId, 'single');
                                const cardbackUrl = `${GITHUB_BASE}/${gameConfig.cardback}`;
                                return (
                                  <div style={{
                                    background: 'rgba(31,41,55,0.8)',
                                    borderRadius: 12,
                                    padding: 16,
                                    border: '2px solid rgba(245,158,11,0.55)',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center'
                                  }}>
                                    <img
                                      src={packImageUrl}
                                      alt="Free Starter"
                                      style={{ width: 100, height: 150, objectFit: 'cover', borderRadius: 8, marginBottom: 10 }}
                                      onError={(e) => e.target.src = cardbackUrl}
                                    />
                                    <div style={{ color: '#fbbf24', fontSize: 14, fontWeight: 'bold', marginBottom: 2 }}>Free Starter</div>
                                    <div style={{ color: '#9ca3af', fontSize: 11, marginBottom: 8 }}>5 packs (one-time)</div>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 4, marginBottom: 8 }}>
                                      <img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />
                                      <span style={{ color: '#fbbf24', fontSize: 16, fontWeight: 'bold' }}>0</span>
                                    </div>
                                    <button
                                      onClick={() => setPurchaseConfirm({ 
                                        type: 'freeStarter', 
                                        gameId: game.id,
                                        setId: setId,
                                        title: `Free Starter - ${setConfig.name}`, 
                                        cost: 0, 
                                        details: `5 free packs for ${game.name} - ${setConfig.name}.` 
                                      })}
                                      disabled={isClaimed}
                                      style={{
                                        width: '100%',
                                        padding: '8px',
                                        background: isClaimed ? '#374151' : 'linear-gradient(90deg, #f59e0b, #f97316)',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: 6,
                                        cursor: isClaimed ? 'not-allowed' : 'pointer',
                                        fontWeight: 'bold',
                                        fontSize: 12,
                                        opacity: isClaimed ? 0.5 : 1
                                      }}
                                    >
                                      {isClaimed ? 'Claimed' : 'Claim'}
                                    </button>
                                  </div>
                                );
                              })()}
                              
                              {/* God Pack Test - per game/set */}
                              {(() => {
                                const packImageUrl = buildProductImageUrl(game.id, setId, 'single');
                                const cardbackUrl = `${GITHUB_BASE}/${gameConfig.cardback}`;
                                return (
                              <div style={{
                                background: 'rgba(31,41,55,0.8)',
                                borderRadius: 12,
                                padding: 16,
                                border: '2px solid rgba(236,72,153,0.55)',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center'
                              }}>
                                <img
                                  src={packImageUrl}
                                  alt="God Pack"
                                  style={{ width: 100, height: 150, objectFit: 'cover', borderRadius: 8, marginBottom: 10, boxShadow: '0 0 20px rgba(236,72,153,0.3)' }}
                                  onError={(e) => e.target.src = cardbackUrl}
                                />
                                <div style={{ color: '#f472b6', fontSize: 14, fontWeight: 'bold', marginBottom: 2 }}>God Pack</div>
                                <div style={{ color: '#9ca3af', fontSize: 11, marginBottom: 8 }}>Test only</div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 4, marginBottom: 8 }}>
                                  <img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />
                                  <span style={{ color: '#fbbf24', fontSize: 16, fontWeight: 'bold' }}>0</span>
                                </div>
                                <button
                                  onClick={() => setPurchaseConfirm({ 
                                    type: 'godpack', 
                                    gameId: game.id,
                                    setId: setId,
                                    title: `God Pack - ${setConfig.name}`, 
                                    cost: 0, 
                                    details: `Free god pack for ${game.name} - ${setConfig.name}.` 
                                  })}
                                  style={{
                                    width: '100%',
                                    padding: '8px',
                                    background: 'linear-gradient(90deg, #ec4899, #a855f7)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: 6,
                                    cursor: 'pointer',
                                    fontWeight: 'bold',
                                    fontSize: 12
                                  }}
                                >
                                  Get
                                </button>
                              </div>
                                );
                              })()}
                              
                              {/* Products from config */}
                              {Object.entries(setConfig.sealedProducts || {}).map(([productType, productConfig]) => {
                                const price = getProductPrice(game.id, setId, productType);
                                const canAfford = rations >= price;
                                const packs = productConfig.packs || 1;
                                const packSize = setConfig.packStructure?.size || 8;
                                const isSinglePack = packs === 1;
                                const productImageUrl = buildProductImageUrl(game.id, setId, productType);
                                const cardbackUrl = `${GITHUB_BASE}/${gameConfig.cardback}`;
                                
                                const guaranteedText = (productConfig.guaranteed || []).map(g => {
                                  const rarityName = gameConfig.rarities?.find(r => r.id === g.rarity)?.name || g.rarity;
                                  return `${g.count} ${rarityName}`;
                                }).join(', ');
                                
                                let borderColor = 'rgba(168,85,247,0.3)';
                                if (packs >= 100) borderColor = 'rgba(251,191,36,0.4)';
                                else if (packs >= 20) borderColor = 'rgba(59,130,246,0.4)';
                                else if (packs >= 5) borderColor = 'rgba(16,185,129,0.4)';
                                
                                return (
                                  <div key={productType} style={{
                                    background: 'rgba(31,41,55,0.8)',
                                    borderRadius: 12,
                                    padding: 16,
                                    border: `2px solid ${borderColor}`,
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center'
                                  }}>
                                    <img 
                                      src={productImageUrl}
                                      alt={productConfig.name || productType}
                                      style={{ width: 100, height: 150, objectFit: 'cover', borderRadius: 8, marginBottom: 10 }}
                                      onError={(e) => e.target.src = cardbackUrl}
                                    />
                                    <div style={{ color: 'white', fontSize: 14, fontWeight: 'bold', marginBottom: 2, textAlign: 'center' }}>
                                      {productConfig.name || productType}
                                    </div>
                                    <div style={{ color: '#9ca3af', fontSize: 11, marginBottom: 2, textAlign: 'center' }}>
                                      {packs} pack{packs > 1 ? 's' : ''} ({packs * packSize} cards)
                                    </div>
                                    {guaranteedText && (
                                      <div style={{ color: '#10b981', fontSize: 10, marginBottom: 6, textAlign: 'center' }}>
                                        ⭐ {guaranteedText}
                                      </div>
                                    )}
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 4, marginBottom: 8 }}>
                                      <img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />
                                      <span style={{ color: '#fbbf24', fontSize: 16, fontWeight: 'bold' }}>{price.toFixed(2)}</span>
                                    </div>
                                    <button
                                      onClick={() => setPurchaseConfirm({
                                        gameId: game.id,
                                        setId: setId,
                                        productType,
                                        isSealedProduct: !isSinglePack,
                                        title: `${productConfig.name || productType}`,
                                        cost: price,
                                        details: `${packs} pack${packs > 1 ? 's' : ''} for ${game.name} - ${setConfig.name}.${guaranteedText ? ` Guaranteed: ${guaranteedText}.` : ''}`
                                      })}
                                      disabled={!canAfford}
                                      style={{
                                        width: '100%',
                                        padding: '8px',
                                        background: canAfford ? 'linear-gradient(90deg, #9333ea, #6366f1)' : '#374151',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: 6,
                                        cursor: canAfford ? 'pointer' : 'not-allowed',
                                        fontWeight: 'bold',
                                        fontSize: 12,
                                        opacity: canAfford ? 1 : 0.5
                                      }}
                                    >
                                      {canAfford ? 'Buy' : 'Need More'}
                                    </button>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  );
                })}
                  </>
                )}


                {shopTab === 'sell' && (
                  <div style={{ maxWidth: 1200, margin: '0 auto', padding: 16, borderRadius: 16, background: 'rgba(17,24,39,0.55)', border: '1px solid rgba(255,255,255,0.10)' }}>
                    <div style={{ display: 'flex', alignItems: 'baseline', justifyContent: 'space-between', gap: 16, flexWrap: 'wrap', marginBottom: 10 }}>
                      <h3 style={{ margin: 0, fontSize: 22, fontWeight: 900 }}>Sell to Shop</h3>
                      <div style={{ color: '#9ca3af', fontSize: 12 }}>
                        Shop buys at <b>{Math.round(SELL_TO_SHOP_RATE * 100)}%</b> market value (incl. holo)
                      </div>
                    </div>
                    <div style={{ color: '#d1d5db', fontSize: 13, marginBottom: 14, lineHeight: 1.4 }}>
                      Select a card below to sell. The shop pays <b>{Math.round(SELL_TO_SHOP_RATE * 100)}%</b> of the current market value (and <b>{Math.round(SELL_TO_SHOP_RATE * 100)}%</b> of holo value for foils).
                    </div>

                    {/* Filters */}
                    <div style={{ display: 'flex', gap: 12, marginBottom: 16, flexWrap: 'wrap' }}>
                      <select
                        value={sellGameFilter}
                        onChange={(e) => {
                          setSellGameFilter(e.target.value);
                          setSellSetFilter('all');
                        }}
                        style={{ 
                          padding: '8px 12px',
                          borderRadius: 8,
                          border: '1px solid rgba(168,85,247,0.4)',
                          background: 'rgba(17,24,39,0.85)',
                          color: 'white',
                          fontSize: 13
                        }}
                      >
                        <option value="all">All Games</option>
                        {gamesIndex.games.filter(g => g.enabled).map(game => (
                          <option key={game.id} value={game.id}>{game.name}</option>
                        ))}
                      </select>
                      <select
                        value={sellSetFilter}
                        onChange={(e) => setSellSetFilter(e.target.value)}
                        style={{ 
                          padding: '8px 12px',
                          borderRadius: 8,
                          border: '1px solid rgba(168,85,247,0.4)',
                          background: 'rgba(17,24,39,0.85)',
                          color: 'white',
                          fontSize: 13
                        }}
                      >
                        <option value="all">All Sets</option>
                        {sellGameFilter !== 'all' && gameConfigs[sellGameFilter]?.sets.map(setId => {
                          const sc = setConfigs[sellGameFilter]?.[setId];
                          return (
                            <option key={setId} value={setId}>{sc?.name || setId}</option>
                          );
                        })}
                      </select>
                    </div>

                    <div style={{ marginBottom: 14, padding: '12px 12px', borderRadius: 14, border: '1px solid rgba(255,255,255,0.10)', background: 'rgba(0,0,0,0.18)' }}>
                      <div style={{ fontSize: 16, fontWeight: 900, marginBottom: 8 }}>Sealed Product</div>
                      <div style={{ color: '#9ca3af', fontSize: 12, marginBottom: 12 }}>
                        Shop pays <b>{Math.round(SEALED_SELL_RATE * 100)}%</b> of market value.
                      </div>

                      {/* Dynamic list of owned sealed products */}
                      {(() => {
                        // Collect all owned sealed products
                        const ownedProducts = [];
                        
                        // First, add single packs from packInventory (grouped by game/set)
                        const packsByGameSet = {};
                        packInventory.forEach(pack => {
                          const gameId = pack.gameId || 'tta';
                          const setId = pack.setId || 'base-set';
                          
                          // Apply filters
                          if (sellGameFilter !== 'all' && gameId !== sellGameFilter) return;
                          if (sellSetFilter !== 'all' && setId !== sellSetFilter) return;
                          
                          const key = `${gameId}|${setId}`;
                          if (!packsByGameSet[key]) {
                            packsByGameSet[key] = {
                              gameId,
                              setId,
                              count: 0,
                              packs: []
                            };
                          }
                          packsByGameSet[key].count++;
                          packsByGameSet[key].packs.push(pack);
                        });
                        
                        Object.values(packsByGameSet).forEach(group => {
                          const gc = gameConfigs[group.gameId];
                          const sc = setConfigs[group.gameId]?.[group.setId];
                          const price = getProductPrice(group.gameId, group.setId, 'single');
                          ownedProducts.push({
                            type: 'single',
                            gameId: group.gameId,
                            setId: group.setId,
                            gameName: gc?.name || group.gameId,
                            setName: sc?.name || group.setId,
                            productName: 'Single Pack',
                            count: group.count,
                            price,
                            payout: parseFloat((price * SEALED_SELL_RATE).toFixed(2)),
                            packToSell: group.packs[0]
                          });
                        });
                        
                        // Then add sealed inventory items
                        Object.entries(sealedInventory).forEach(([gameId, sets]) => {
                          // Apply game filter
                          if (sellGameFilter !== 'all' && gameId !== sellGameFilter) return;
                          
                          Object.entries(sets).forEach(([setId, products]) => {
                            // Apply set filter
                            if (sellSetFilter !== 'all' && setId !== sellSetFilter) return;
                            
                            Object.entries(products).forEach(([productType, count]) => {
                              if (count > 0 && productType !== 'single') {
                                const gc = gameConfigs[gameId];
                                const sc = setConfigs[gameId]?.[setId];
                                const productConfig = sc?.sealedProducts?.[productType];
                                const price = getProductPrice(gameId, setId, productType);
                                ownedProducts.push({
                                  type: productType,
                                  gameId,
                                  setId,
                                  gameName: gc?.name || gameId,
                                  setName: sc?.name || setId,
                                  productName: productConfig?.name || productType,
                                  count,
                                  price,
                                  payout: parseFloat((price * SEALED_SELL_RATE).toFixed(2))
                                });
                              }
                            });
                          });
                        });
                        
                        if (ownedProducts.length === 0) {
                          return (
                            <div style={{ color: '#6b7280', fontSize: 13, textAlign: 'center', padding: 20 }}>
                              {sellGameFilter === 'all' && sellSetFilter === 'all' 
                                ? "You don't own any sealed products to sell."
                                : "No sealed products match your filter."}
                            </div>
                          );
                        }
                        
                        return (
                          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))', gap: 10 }}>
                            {ownedProducts.map((product, idx) => (
                              <div key={`${product.gameId}-${product.setId}-${product.type}-${idx}`} style={{ 
                                padding: 12, 
                                borderRadius: 12, 
                                background: 'rgba(17,24,39,0.55)', 
                                border: '1px solid rgba(168,85,247,0.3)' 
                              }}>
                                <div style={{ fontWeight: 900, marginBottom: 2, fontSize: 14 }}>{product.productName}</div>
                                <div style={{ color: '#9ca3af', fontSize: 11, marginBottom: 4 }}>
                                  {product.gameName} • {product.setName}
                                </div>
                                <div style={{ color: '#a855f7', fontSize: 12, fontWeight: 'bold', marginBottom: 6 }}>
                                  You have: {product.count}
                                </div>
                                <div style={{ color: '#d1d5db', fontSize: 11, marginBottom: 8 }}>
                                  Market: <b>{product.price.toFixed(2)}</b> • Sell: <span style={{ color: '#fbbf24' }}><b>{product.payout.toFixed(2)}</b></span>
                                </div>
                                <button
                                  onClick={() => {
                                    if (product.type === 'single' && product.packToSell) {
                                      sellSinglePack(product.packToSell.id);
                                    } else {
                                      sellSealedProduct(product.gameId, product.setId, product.type);
                                    }
                                  }}
                                  style={{
                                    width: '100%',
                                    padding: '8px 12px',
                                    borderRadius: 8,
                                    border: 'none',
                                    background: 'linear-gradient(90deg, #9333ea, #6366f1)',
                                    color: 'white',
                                    cursor: 'pointer',
                                    fontWeight: 800,
                                    fontSize: 12
                                  }}
                                >
                                  Sell for {product.payout.toFixed(2)}
                                </button>
                              </div>
                            ))}
                          </div>
                        );
                      })()}
                    </div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: 12, marginBottom: 14, alignItems: 'center' }}>
                      <input
                        value={shopSellSearch}
                        onChange={(e) => setShopSellSearch(e.target.value)}
                        placeholder="Search owned cards..."
                        style={{
                          width: '100%',
                          padding: '10px 12px',
                          borderRadius: 12,
                          border: '1px solid rgba(255,255,255,0.12)',
                          background: 'rgba(0,0,0,0.25)',
                          color: 'white',
                          outline: 'none'
                        }}
                      />

                      <select
                        value={shopSellFilter}
                        onChange={(e) => setShopSellFilter(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '10px 12px',
                          borderRadius: 12,
                          border: '1px solid rgba(255,255,255,0.12)',
                          background: 'rgba(0,0,0,0.25)',
                          color: 'white',
                          outline: 'none'
                        }}
                      >
                        <option value="all">All rarities</option>
                        {RARITY_ORDER.map(rarity => (
                          <option key={rarity} value={rarity} style={{ textTransform: 'capitalize' }}>
                            {currentGameConfig.rarities.find(r => r.id === rarity)?.name || rarity}
                          </option>
                        ))}
                      </select>

                      <select
                        value={shopSellVariant}
                        onChange={(e) => setShopSellVariant(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '10px 12px',
                          borderRadius: 12,
                          border: '1px solid rgba(255,255,255,0.12)',
                          background: 'rgba(0,0,0,0.25)',
                          color: 'white',
                          outline: 'none'
                        }}
                      >
                        <option value="any">Any owned</option>
                        <option value="normal">Normal only</option>
                        <option value="holo">Holo only</option>
                      </select>

                      <select
                        value={shopSellSort}
                        onChange={(e) => setShopSellSort(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '10px 12px',
                          borderRadius: 12,
                          border: '1px solid rgba(255,255,255,0.12)',
                          background: 'rgba(0,0,0,0.25)',
                          color: 'white',
                          outline: 'none'
                        }}
                      >
                        <option value="payout">Best payout</option>
                        <option value="owned">Most owned</option>
                        <option value="name">Name (A-Z)</option>
                        <option value="rarity">Rarity</option>
                      </select>
                    </div>

                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))', gap: 16 }}>
                      {getShopSellCards().map(card => {
                        const colors = RARITY_COLORS[card.rarity] || RARITY_COLORS.common;
                        const canSellNormal = card.ownedNormal > 0;
                        const canSellHolo = card.ownedHolo > 0;
                        return (
                          <div key={card.id} style={{ borderRadius: 16, padding: 12, background: 'rgba(31,41,55,0.72)', border: `2px solid ${colors.border}55`, boxShadow: '0 10px 30px rgba(0,0,0,0.25)' }}>
                            <div style={{ display: 'flex', gap: 10 }}>
                              <div style={{ position: 'relative', width: 90, flex: '0 0 auto' }}>
                                <div style={{ width: 90, aspectRatio: '2.5/3.5', borderRadius: 12, overflow: 'hidden', border: `2px solid ${colors.border}` }}>
                                  <img
                                    src={card.image}
                                    alt={card.name}
                                    style={{ width: '100%', height: '100%', objectFit: 'cover', cursor: 'zoom-in' }}
                                    onClick={() => setEnlargedCard({ ...card, marketValue: card.marketValue, priceChange: 0 })}
                                    loading="lazy"
                                  />
                                </div>
                                <div style={{ position: 'absolute', top: 6, right: 6, display: 'flex', gap: 6 }}>
                                  {canSellNormal && (
                                    <div style={{ background: 'rgba(0,0,0,0.55)', padding: '3px 7px', borderRadius: 12, border: `2px solid ${colors.border}`, color: 'white', fontWeight: 800, fontSize: 11, textShadow: '0 1px 2px rgba(0,0,0,0.85)' }}>
                                      x{card.ownedNormal}
                                    </div>
                                  )}
                                  {canSellHolo && (
                                    <div className="holo-badge" style={{ padding: '3px 7px', borderRadius: 12, border: `2px solid ${colors.border}`, fontWeight: 800, fontSize: 11 }}>
                                      x{card.ownedHolo}
                                    </div>
                                  )}
                                </div>
                              </div>

                              <div style={{ flex: 1, minWidth: 0 }}>
                                <div style={{ fontWeight: 900, fontSize: 14, color: 'white', lineHeight: 1.2, marginBottom: 6, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                  {card.name}
                                </div>
                                <div style={{ display: 'inline-flex', alignItems: 'center', gap: 6, padding: '4px 8px', borderRadius: 999, background: `${colors.bg}55`, border: `1px solid ${colors.border}55`, color: colors.text, fontWeight: 800, fontSize: 11, marginBottom: 8 }}>
                                  {card.rarity}
                                </div>

                                <div style={{ display: 'grid', gap: 6 }}>
                                  {canSellNormal && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 6, color: '#d1d5db', fontSize: 12 }}>
                                      <span style={{ opacity: 0.85 }}>Normal payout:</span>
                                      <img src="./rations.png" alt="" style={{ width: 14, height: 14 }} />
                                      <b style={{ color: '#fbbf24' }}>{card.payout.toFixed(2)}</b>
                                    </div>
                                  )}
                                  {canSellHolo && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: 6, color: '#d1d5db', fontSize: 12 }}>
                                      <span style={{ opacity: 0.85 }}>Holo payout:</span>
                                      <img src="./rations.png" alt="" style={{ width: 14, height: 14, opacity: 0.9 }} />
                                      <b className="rainbow-text">{card.holoPayout.toFixed(2)}</b>
                                    </div>
                                  )}
                                </div>

                                <button
                                  onClick={() => setSellConfirm({ id: card.id, name: card.name, rarity: card.rarity })}
                                  style={{
                                    marginTop: 10,
                                    width: '100%',
                                    padding: '10px 12px',
                                    borderRadius: 12,
                                    border: 'none',
                                    cursor: 'pointer',
                                    fontWeight: 900,
                                    color: 'white',
                                    background: 'linear-gradient(90deg, #dc2626, #b91c1c)',
                                    boxShadow: '0 10px 22px rgba(0,0,0,0.35)'
                                  }}
                                >
                                  Sell
                                </button>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>

                    {getShopSellCards().length === 0 && (
                      <div style={{ marginTop: 14, color: '#9ca3af', textAlign: 'center' }}>No cards match your filters.</div>
                    )}
                  </div>
                )}


              </div>
            )}

            {view === 'opening' && (
              <div>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 24, flexWrap: 'wrap', gap: 12 }}>
                  <h2 style={{ color: 'white', fontSize: 24, fontWeight: 'bold', margin: 0 }}>Pack #{packCount}</h2>
                  <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                    {packPhase === 'stack' && (
                      <>
                        <button 
                          onMouseDown={() => setIsPeeking(true)}
                          onMouseUp={() => setIsPeeking(false)}
                          onMouseLeave={() => setIsPeeking(false)}
                          onTouchStart={() => setIsPeeking(true)}
                          onTouchEnd={() => setIsPeeking(false)}
                          style={{ padding: '8px 16px', background: '#6366f1', color: 'white', border: 'none', borderRadius: 8, cursor: 'pointer', userSelect: 'none' }}
                        >
                          Hold to Peek
                        </button>
                        <button onClick={revealAllCards} style={{ padding: '8px 16px', background: '#9333ea', color: 'white', border: 'none', borderRadius: 8, cursor: 'pointer' }}>
                          Reveal All
                        </button>
                      </>
                    )}
                    {packPhase === 'revealed' && packInventory.length > 0 && (
                      <button onClick={() => navigate('home')} style={{ padding: '8px 16px', background: 'linear-gradient(90deg, #9333ea, #ec4899)', color: 'white', border: 'none', borderRadius: 8, cursor: 'pointer' }}>
                        Open Another Pack ({packInventory.length} available)
                      </button>
                    )}
                    <button onClick={() => setView('home')} style={{ padding: '8px 16px', background: '#374151', color: 'white', border: 'none', borderRadius: 8, cursor: 'pointer' }}>
                      Back
                    </button>
                  </div>
                </div>

                {/* Phase 1: Sealed Pack - Rip to Open */}
                {(packPhase === 'sealed' || packPhase === 'ripping') && (
                  <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 24 }}>
                    <p style={{ color: '#9ca3af', fontSize: 14, margin: 0 }}>
                      {packPhase === 'sealed' ? 'Drag across the top to rip open the pack →' : 'Opening...'}
                    </p>
                    
                    <div 
                      className="pack-rip-container"
                      ref={packRef}
                      onMouseDown={handleRipStart}
                      onMouseMove={handleRipMove}
                      onMouseUp={handleRipEnd}
                      onMouseLeave={handleRipEnd}
                      onTouchStart={handleRipStart}
                      onTouchMove={handleRipMove}
                      onTouchEnd={handleRipEnd}
                    >
                      <div className="pack-wrapper">
                        <div className="pack-body">
                          <img 
                            src={openingPackImageUrl} 
                            alt="Booster Pack" 
                            style={{ width: '100%', height: '100%', objectFit: 'cover', pointerEvents: 'none' }}
                            draggable={false}
                            onError={(e) => e.target.src = openingCardbackUrl}
                          />
                        </div>
                        
                        {/* Tear progress indicator */}
                        {packPhase === 'sealed' && ripProgress > 0 && (
                          <div className="pack-tear-progress" style={{ width: `${ripProgress}%` }} />
                        )}
                        
                        {/* Pack top (tearable) */}
                        <div 
                          className={`pack-top ${packPhase === 'ripping' ? 'pack-top-torn' : ''}`}
                          style={{ 
                            transform: packPhase === 'sealed' && ripProgress > 0 
                              ? `translateX(${ripProgress * 0.5}px) rotate(${ripProgress * 0.1}deg)` 
                              : undefined 
                          }}
                        >
                          <span className="pack-top-text">
                            {ripProgress > 50 ? 'Keep going!' : 'Drag to rip →'}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {/* Phase 2: Card Stack */}
                {packPhase === 'stack' && (
                  <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 24 }}>
                    <p style={{ color: '#9ca3af', fontSize: 14, margin: 0 }}>
                      Click the card to slide it away • {packCards.length - currentCardIndex} cards remaining
                    </p>
                    
                    <div className="card-stack-container">
                      {packCards.map((card, index) => {
                        const colors = RARITY_COLORS[card.rarity] || { bg: '#374151', border: '#6b7280', text: '#d1d5db' };
                        const isSliding = slidingCards.includes(index);
                        const isVisible = index >= currentCardIndex;
                        const stackPosition = index - currentCardIndex;
                        const isTopCard = index === currentCardIndex;
                        
                        if (!isVisible && !isSliding) return null;
                        
                        // Peek offset calculation
                        const peekOffset = isPeeking && isVisible && !isSliding 
                          ? stackPosition * 25 
                          : stackPosition * 2;
                        
                        return (
                          <div
                            key={`${card.id}-${index}`}
                            className={`stacked-card ${isSliding ? 'card-sliding-off' : ''} ${card.isHolo ? 'foil-glow' : ''}`}
                            onClick={() => isTopCard && !isSliding && slideCardAway()}
                            style={{
                              border: `3px solid ${colors.border}`,
                              zIndex: packCards.length - index,
                              transform: `translateY(${peekOffset}px)`,
                              cursor: isTopCard ? 'pointer' : 'default',
                              opacity: isPeeking ? (isTopCard ? 1 : 0.9) : 1
                            }}
                          >
                            <img 
                              src={card.image} 
                              alt={card.name}
                              draggable={false}
                            />
                            {card.isHolo && (
                              <div style={{
                                position: 'absolute',
                                top: 8,
                                right: 8,
                                padding: '4px 8px',
                                borderRadius: 6,
                                fontSize: 10,
                                fontWeight: 'bold',
                                textTransform: 'uppercase'
                              }} className="holo-badge">
                                Holo
                              </div>
                            )}
                            {isTopCard && !isSliding && (
                              <div style={{
                                position: 'absolute',
                                bottom: 12,
                                left: 0,
                                right: 0,
                                textAlign: 'center',
                                color: 'white',
                                fontSize: 12,
                                fontWeight: 'bold',
                                textShadow: '0 2px 8px rgba(0,0,0,0.9)'
                              }}>
                                Tap to continue
                              </div>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                )}

                {/* Phase 3: All Cards Revealed - Grid View */}
                {packPhase === 'revealed' && (
                  <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 24 }}>
                    <p style={{ color: '#10b981', fontSize: 16, fontWeight: 'bold', margin: 0 }}>
                      Pack Complete! {packCards.filter(c => c.isHolo).length > 0 && `✨ ${packCards.filter(c => c.isHolo).length} Holo`}
                    </p>
                    
                    <div className="cards-grid-reveal">
                      {packCards.map((card, index) => {
                        const colors = RARITY_COLORS[card.rarity] || { bg: '#374151', border: '#6b7280', text: '#d1d5db' };
                        return (
                          <div
                            key={`${card.id}-${index}`}
                            className={`grid-card ${card.isHolo ? 'foil-glow' : ''}`}
                            style={{ border: `3px solid ${colors.border}` }}
                            onClick={() => setEnlargedCard(card)}
                          >
                            <img 
                              src={card.image} 
                              alt={card.name}
                            />
                            {card.isHolo && (
                              <div style={{
                                position: 'absolute',
                                top: 4,
                                right: 4,
                                padding: '2px 6px',
                                borderRadius: 4,
                                fontSize: 9,
                                fontWeight: 'bold'
                              }} className="holo-badge">
                                Holo
                              </div>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                )}
              </div>
            )}

            
            {view === 'market' && (
              <div>
                <div style={{ background: 'rgba(0,0,0,0.3)', borderRadius: 12, padding: 24, marginBottom: 24 }}>
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: 12, marginBottom: 24 }}>
                    <h2 style={{ margin: 0, fontSize: 22, color: 'white' }}>Market</h2>
                    <div style={{ color: 'rgba(255,255,255,0.75)', fontSize: 13 }}>
                      7-day movers (Day {movers7d.fromDay} → Day {gameDay})
                    </div>
                  </div>

                  {/* Render each game/set */}
                  {Object.entries(movers7d.byGameSet || {}).map(([gameId, sets]) => (
                    <div key={gameId} style={{ marginBottom: 32 }}>
                      {Object.entries(sets).map(([setId, data]) => (
                        <div key={setId} style={{ marginBottom: 24 }}>
                          <h3 style={{ 
                            color: '#a855f7', 
                            fontSize: 18, 
                            fontWeight: 'bold', 
                            margin: '0 0 16px',
                            padding: '8px 12px',
                            background: 'rgba(168,85,247,0.15)',
                            borderRadius: 8,
                            borderLeft: '4px solid #a855f7'
                          }}>
                            {data.gameName} - {data.setName}
                          </h3>

                          <div style={{ display: 'flex', gap: 24, flexWrap: 'wrap' }}>
                            <div style={{ flex: '1 1 320px', minWidth: 280 }}>
                              <div style={{ fontSize: 14, fontWeight: 700, color: '#34d399', marginBottom: 10 }}>Top 5 Gainers</div>
                              <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
                                {data.gainers.map((row, idx) => (
                                  <button
                                    key={'g7-' + row.card.id}
                                    onClick={() => setEnlargedCard({
                                      ...row.card,
                                      image: buildImageUrl(row.card.gameId, row.card.setId, row.card),
                                      marketValue: row.curVal
                                    })}
                                    style={{
                                      width: '100%',
                                      textAlign: 'left',
                                      borderRadius: 10,
                                      padding: '8px 10px',
                                      border: '1px solid rgba(52,211,153,0.2)',
                                      background: 'rgba(0,0,0,0.25)',
                                      cursor: 'pointer',
                                      color: 'white',
                                      fontSize: 13
                                    }}
                                  >
                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8 }}>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 8, minWidth: 0 }}>
                                        <span style={{ fontWeight: 700, opacity: 0.7, fontSize: 12 }}>{idx + 1}.</span>
                                        <span style={{ fontWeight: 600, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{row.card.name}</span>
                                      </div>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 8, flexShrink: 0 }}>
                                        <span style={{ fontWeight: 800, color: '#34d399', fontSize: 12 }}>+{row.pct.toFixed(1)}%</span>
                                        <span style={{ fontWeight: 700, color: '#fbbf24', fontSize: 12 }}>{row.curVal.toFixed(2)}R</span>
                                      </div>
                                    </div>
                                  </button>
                                ))}
                                {data.gainers.length === 0 && (
                                  <div style={{ color: 'rgba(255,255,255,0.5)', fontSize: 12 }}>No data yet</div>
                                )}
                              </div>
                            </div>

                            <div style={{ flex: '1 1 320px', minWidth: 280 }}>
                              <div style={{ fontSize: 14, fontWeight: 700, color: '#f87171', marginBottom: 10 }}>Top 5 Losers</div>
                              <div style={{ display: 'flex', flexDirection: 'column', gap: 6 }}>
                                {data.losers.map((row, idx) => (
                                  <button
                                    key={'l7-' + row.card.id}
                                    onClick={() => setEnlargedCard({
                                      ...row.card,
                                      image: buildImageUrl(row.card.gameId, row.card.setId, row.card),
                                      marketValue: row.curVal
                                    })}
                                    style={{
                                      width: '100%',
                                      textAlign: 'left',
                                      borderRadius: 10,
                                      padding: '8px 10px',
                                      border: '1px solid rgba(248,113,113,0.2)',
                                      background: 'rgba(0,0,0,0.25)',
                                      cursor: 'pointer',
                                      color: 'white',
                                      fontSize: 13
                                    }}
                                  >
                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8 }}>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 8, minWidth: 0 }}>
                                        <span style={{ fontWeight: 700, opacity: 0.7, fontSize: 12 }}>{idx + 1}.</span>
                                        <span style={{ fontWeight: 600, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{row.card.name}</span>
                                      </div>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 8, flexShrink: 0 }}>
                                        <span style={{ fontWeight: 800, color: '#f87171', fontSize: 12 }}>{row.pct.toFixed(1)}%</span>
                                        <span style={{ fontWeight: 700, color: '#fbbf24', fontSize: 12 }}>{row.curVal.toFixed(2)}R</span>
                                      </div>
                                    </div>
                                  </button>
                                ))}
                                {data.losers.length === 0 && (
                                  <div style={{ color: 'rgba(255,255,255,0.5)', fontSize: 12 }}>No data yet</div>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  ))}
                  
                  {Object.keys(movers7d.byGameSet || {}).length === 0 && (
                    <div style={{ color: 'rgba(255,255,255,0.7)', fontSize: 14, textAlign: 'center', padding: 20 }}>
                      Not enough market history yet. Advance a few days to see price movements.
                    </div>
                  )}
                </div>
              </div>
            )}

{view === 'collection' && (
              <div>
                {/* Collection Stats Header - All Games */}
                <div style={{ background: 'rgba(0,0,0,0.3)', borderRadius: 12, padding: 24, marginBottom: 24 }}>
                  {/* Total Collection Value */}
                  <div style={{ textAlign: 'center', marginBottom: 20 }}>
                    <p style={{ color: '#9ca3af', fontSize: 14, margin: 0 }}>Total Collection Value (All Games)</p>
                    <p style={{ color: 'white', fontSize: 28, fontWeight: 'bold', margin: '8px 0 0', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8 }}>
                      <img src="./rations.png" alt="Rations" style={{ width: 24, height: 24 }} />
                      <span>{totalCollectionValue.toFixed(2)}</span>
                    </p>
                  </div>
                  
                  {/* Per-Game/Set Completion */}
                  <div style={{ display: 'flex', flexWrap: 'wrap', gap: 12, justifyContent: 'center' }}>
                    {gamesIndex.games.filter(g => g.enabled).map(game => {
                      const gameConfig = gameConfigs[game.id];
                      if (!gameConfig) return null;
                      
                      return gameConfig.sets.map(setId => {
                        const setConfig = setConfigs[game.id]?.[setId];
                        if (!setConfig || !setConfig.cards) return null;
                        
                        const totalCards = setConfig.cards.length;
                        let ownedCount = 0;
                        
                        setConfig.cards.forEach(card => {
                          const entry = collection[card.id];
                          if (entry && ((entry.normal || 0) > 0 || (entry.holo || 0) > 0)) {
                            ownedCount++;
                          }
                        });
                        
                        const completionPct = totalCards > 0 ? Math.round((ownedCount / totalCards) * 100) : 0;
                        
                        return (
                          <div 
                            key={`${game.id}-${setId}`}
                            style={{ 
                              padding: '10px 16px', 
                              background: 'rgba(168,85,247,0.15)', 
                              borderRadius: 10, 
                              border: '1px solid rgba(168,85,247,0.3)',
                              minWidth: 180
                            }}
                          >
                            <div style={{ color: '#d1d5db', fontSize: 12, marginBottom: 4 }}>
                              {game.name} - {setConfig.name}
                            </div>
                            <div style={{ display: 'flex', alignItems: 'baseline', gap: 8 }}>
                              <span style={{ color: '#a855f7', fontSize: 20, fontWeight: 'bold' }}>{completionPct}%</span>
                              <span style={{ color: '#9ca3af', fontSize: 12 }}>({ownedCount}/{totalCards})</span>
                            </div>
                          </div>
                        );
                      });
                    })}
                  </div>
                </div>

                {/* Filters */}
                <div style={{ background: 'rgba(0,0,0,0.28)', border: '1px solid rgba(255,255,255,0.08)', borderRadius: 12, padding: 16, marginBottom: 20 }}>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))', gap: 12, alignItems: 'center', marginBottom: 12 }}>
                    <input
                      value={collectionSearch}
                      onChange={(e) => setCollectionSearch(e.target.value)}
                      placeholder="Search cards…"
                      style={{ 
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: 'rgba(17,24,39,0.85)',
                        color: 'white',
                        outline: 'none'
                      }}
                    />
                    
                    {/* Game Filter */}
                    <select
                      value={collectionGameFilter}
                      onChange={(e) => {
                        setCollectionGameFilter(e.target.value);
                        setCollectionSetFilter('all');
                      }}
                      style={{ 
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(168,85,247,0.4)',
                        background: 'rgba(17,24,39,0.85)',
                        color: 'white',
                        outline: 'none'
                      }}
                    >
                      <option value="all">All Games</option>
                      {gamesIndex.games.filter(g => g.enabled).map(game => (
                        <option key={game.id} value={game.id}>{game.name}</option>
                      ))}
                    </select>
                    
                    {/* Set Filter */}
                    <select
                      value={collectionSetFilter}
                      onChange={(e) => setCollectionSetFilter(e.target.value)}
                      style={{ 
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(168,85,247,0.4)',
                        background: 'rgba(17,24,39,0.85)',
                        color: 'white',
                        outline: 'none'
                      }}
                    >
                      <option value="all">All Sets</option>
                      {collectionGameFilter !== 'all' && gameConfigs[collectionGameFilter]?.sets.map(setId => {
                        const sc = setConfigs[collectionGameFilter]?.[setId];
                        return (
                          <option key={setId} value={setId}>{sc?.name || setId}</option>
                        );
                      })}
                    </select>

                    <select
                      value={ownedFilter}
                      onChange={(e) => setOwnedFilter(e.target.value)}
                      style={{ 
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: 'rgba(17,24,39,0.85)',
                        color: 'white',
                        outline: 'none'
                      }}
                    >
                      <option value="all">All cards</option>
                      <option value="owned">Owned</option>
                      <option value="unowned">Unowned</option>
                    </select>

                    <select
                      value={holoFilter}
                      onChange={(e) => setHoloFilter(e.target.value)}
                      style={{ 
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: 'rgba(17,24,39,0.85)',
                        color: 'white',
                        outline: 'none'
                      }}
                    >
                      <option value="all">Holo: Any</option>
                      <option value="hasHolo">Has holo</option>
                      <option value="noHolo">No holo</option>
                    </select>

                    <select
                      value={sortKey}
                      onChange={(e) => setSortKey(e.target.value)}
                      style={{ 
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: 'rgba(17,24,39,0.85)',
                        color: 'white',
                        outline: 'none'
                      }}
                    >
                      <option value="owned">Sort: Owned</option>
                      <option value="name">Sort: Name</option>
                      <option value="rarity">Sort: Rarity</option>
                      <option value="value">Sort: Market Value</option>
                      <option value="holoValue">Sort: Holo Value</option>
                      <option value="change">Sort: 24h Change</option>
                      <option value="holoMult">Sort: Holo Multiplier</option>
                    </select>

                    <button
                      onClick={() => setSortDir(sortDir === 'asc' ? 'desc' : 'asc')}
                      style={{
                        padding: '10px 12px',
                        borderRadius: 10,
                        border: '1px solid rgba(255,255,255,0.10)',
                        background: 'rgba(55,65,81,0.85)',
                        color: 'white',
                        cursor: 'pointer',
                        fontWeight: 800,
                        minWidth: 44
                      }}
                      title="Toggle sort direction"
                    >
                      {sortDir === 'asc' ? '↑' : '↓'}
                    </button>
                  </div>

                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 12, flexWrap: 'wrap' }}>
                    <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                      <button onClick={() => setCollectionFilter('all')} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: collectionFilter === 'all' ? '#9333ea' : '#374151', color: 'white' }}>
                        All
                      </button>
                      {RARITY_ORDER.map(rarity => {
                        const rarityConfig = currentGameConfig.rarities.find(r => r.id === rarity);
                        return (
                          <button key={rarity} onClick={() => setCollectionFilter(rarity)} style={{ padding: '8px 16px', borderRadius: 8, border: 'none', cursor: 'pointer', background: collectionFilter === rarity ? (RARITY_COLORS[rarity]?.bg || '#374151') : '#374151', color: 'white' }}>
                            {rarityConfig?.name || rarity}
                          </button>
                        );
                      })}
                    </div>

                    <label style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#e5e7eb', fontSize: 13, userSelect: 'none' }}>
                      <input type="checkbox" checked={hideUnknown} onChange={(e) => setHideUnknown(e.target.checked)} />
                      Hide unknown
                    </label>
                  </div>
                </div>

                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(165px, 1fr))', gap: 16 }}>
                  {getCollectionCards().map(card => {
                    const colors = RARITY_COLORS[card.rarity] || { bg: '#374151', border: '#6b7280', text: '#d1d5db' };
                    const marketValue = (typeof card.marketValue === 'number') ? card.marketValue : (marketValues[card.id] || 1);
                    const priceChange = (typeof card.priceChange === 'number') ? card.priceChange : 0;
                    const holoMult = getHoloMultiplier(card.id);
                    const holoValue = marketValue * holoMult;
return (
                      <div 
                        key={card.id} 
                        style={{ 
                          aspectRatio: '2.5/3.5', 
                          borderRadius: 12, 
                          border: `3px solid ${colors.border}`, 
                          overflow: 'visible', 
                          background: '#1f2937', 
                          position: 'relative', 
                          opacity: card.owned === 0 ? 0.4 : 1,
                        }}
                        title={card.owned > 0 ? `${card.name} - ${marketValue.toFixed(2)}` : '???'}
                      >
                        <div 
                          style={{ width: '100%', height: '100%', borderRadius: 12, overflow: 'hidden', cursor: card.owned > 0 ? 'zoom-in' : 'default' }}
                          onClick={() => {
                            if (card.owned > 0) setEnlargedCard({ ...card, marketValue, priceChange });
                          }}
                        >
                          {card.owned > 0 ? (
                            <img 
                              src={card.image} 
                              alt={card.name} 
                              style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                              loading="lazy"
                            />
                          ) : (
                            <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', background: '#111827' }}>
                              <span style={{ fontSize: 48 }}>❓</span>
                            </div>
                          )}
                        </div>
                        
                        {card.owned > 0 && (
                          <>
                            {/* Count badges */}
                            <div style={{ position: 'absolute', top: 8, right: 8, display: 'flex', gap: 6, zIndex: 5 }}>
                              {card.ownedNormal > 0 && (
                                <div style={{ 
                                  background: 'rgba(0,0,0,0.55)', 
                                  padding: '4px 8px', 
                                  borderRadius: 12, 
                                  border: `2px solid ${colors.border}`,
                                  color: 'white',
                                  fontWeight: 800,
                                  fontSize: 12,
                                  textShadow: '0 1px 2px rgba(0,0,0,0.85)'
                                }}>
                                  x{card.ownedNormal}
                                </div>
                              )}
                              {card.ownedHolo > 0 && (
                                <div className="holo-badge" style={{ 
                                  padding: '4px 8px', 
                                  borderRadius: 12,
                                  border: `2px solid ${colors.border}`,
                                  fontWeight: 800,
                                  fontSize: 12
                                }}>
                                  x{card.ownedHolo}
                                </div>
                              )}
                            </div>
                            
                            {/* Market value + change */}
                            <div style={{ position: 'absolute', top: 8, left: 8, background: 'rgba(0,0,0,0.8)', padding: '4px 8px', borderRadius: 8, display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: 2 }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                                <img src="./rations.png" alt="R" style={{ width: 14, height: 14 }} />
                                <span style={{ color: '#fbbf24', fontSize: 12, fontWeight: 'bold' }}>{marketValue.toFixed(2)}</span>
                              </div>
                              {card.ownedHolo > 0 && (
                                <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                                  <img src="./rations.png" alt="" style={{ width: 14, height: 14, opacity: 0.9 }} />
                                  <span className="rainbow-text" style={{ fontSize: 12, fontWeight: 'bold' }}>{holoValue.toFixed(2)}</span>
                                </div>
                              )}
                              {priceChange !== 0 && (
                                <span style={{ fontSize: 10, fontWeight: 'bold', color: priceChange > 0 ? '#10b981' : '#ef4444' }}>
                                  {priceChange > 0 ? '↑' : '↓'} {Math.abs(priceChange).toFixed(1)}%
                                </span>
                              )}
                            </div>
</>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            )}
          
            {view === 'settings' && (
              <div style={{ maxWidth: 980, margin: '0 auto' }}>
                <h2 style={{ fontSize: 28, fontWeight: 800, marginBottom: 12 }}>Settings</h2>

                {settingsMsg && (
                  <div style={{ marginBottom: 16, padding: '10px 12px', borderRadius: 10, background: 'rgba(34,197,94,0.12)', border: '1px solid rgba(34,197,94,0.25)', color: '#bbf7d0' }}>
                    {settingsMsg}
                  </div>
                )}

                <div style={{ display: 'grid', gap: 16 }}>
                  <div style={{ padding: 16, borderRadius: 14, background: 'rgba(17,24,39,0.6)', border: '1px solid rgba(255,255,255,0.08)' }}>
                    <h3 style={{ margin: 0, marginBottom: 12, fontSize: 18 }}>Save Info</h3>
                    <div style={{ display: 'grid', gap: 8, color: '#e5e7eb', fontSize: 14 }}>
                      <div>Day: <b>{gameDay}</b></div>
                      <div>Rations: <b>{rations.toFixed(2)}</b></div>
                      <div>Packs Opened: <b>{packCount}</b></div>
                      <div>Packs Owned: <b>{packInventory.length}</b></div>
                      <div>Collection: <b>N {stats.uniqueNormalOwned}/{stats.totalCards}</b> • <b>H {stats.uniqueHoloOwned}/{stats.totalCards}</b></div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: 8, flexWrap: 'wrap' }}>
                        <span>Save Seed:</span>
                        <code style={{ padding: '3px 8px', borderRadius: 999, background: 'rgba(0,0,0,0.35)', border: '1px solid rgba(255,255,255,0.10)', color: '#f3f4f6' }}>{saveSeed || '—'}</code>
                        <button onClick={() => copyToClipboard(String(saveSeed || ''))} style={{ padding: '6px 10px', borderRadius: 10, border: 'none', cursor: 'pointer', background: 'rgba(107,114,128,0.35)', color: 'white' }}>
                          Copy
                        </button>
                      </div>
                    </div>
                    <p style={{ marginTop: 12, color: '#9ca3af', fontSize: 12, lineHeight: 1.4 }}>
                      Note: Saves live in your browser's localStorage. GitHub Pages can't write back to your repo from the client — exporting/importing JSON is the reliable way to move saves between devices or restore progress.
                    </p>
                  </div>

                  <div style={{ padding: 16, borderRadius: 14, background: 'rgba(17,24,39,0.6)', border: '1px solid rgba(255,255,255,0.08)' }}>
                    <h3 style={{ margin: 0, marginBottom: 12, fontSize: 18 }}>Deterministic Mode (for testing)</h3>
                    <div style={{ display: 'grid', gap: 10 }}>
                      <label style={{ display: 'flex', alignItems: 'center', gap: 10, color: '#e5e7eb' }}>
                        <input type="checkbox" checked={debugEnabled} onChange={(e) => setDebugEnabled(e.target.checked)} />
                        Enable deterministic RNG (reproducible randomness)
                      </label>

                      <div style={{ display: 'grid', gap: 6 }}>
                        <div style={{ color: '#9ca3af', fontSize: 12 }}>Optional seed override (leave blank to use Save Seed):</div>
                        <input
                          value={debugSeed}
                          onChange={(e) => setDebugSeed(e.target.value)}
                          placeholder="e.g. 123456789"
                          style={{ padding: '10px 12px', borderRadius: 10, border: '1px solid rgba(255,255,255,0.15)', background: 'rgba(0,0,0,0.35)', color: 'white' }}
                        />
                      </div>

                      <div style={{ display: 'flex', gap: 10, flexWrap: 'wrap' }}>
                        <button onClick={applyDebugSettings} style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: '#9333ea', color: 'white', fontWeight: 700 }}>
                          Save Debug Settings
                        </button>
                        <button onClick={resetDeterministicStream} style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: 'rgba(107,114,128,0.35)', color: 'white', fontWeight: 700 }}>
                          Reset RNG Stream
                        </button>
                        <button onClick={() => copyToClipboard(String(getActiveSeed() || ''))} style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: 'rgba(107,114,128,0.35)', color: 'white', fontWeight: 700 }}>
                          Copy Active Seed
                        </button>
                      </div>

                      <div style={{ color: '#9ca3af', fontSize: 12, lineHeight: 1.4 }}>
                        Deterministic mode only changes randomness when enabled. When it's off, everything behaves normally.
                        If you want a fully reproducible run, export your save JSON (it includes day, market, picks, collection, and RNG stream state).
                      </div>
                    </div>
                  </div>

                  <div style={{ padding: 16, borderRadius: 14, background: 'rgba(17,24,39,0.6)', border: '1px solid rgba(255,255,255,0.08)' }}>
                    <h3 style={{ margin: 0, marginBottom: 12, fontSize: 18 }}>Export / Import Save</h3>
                    <div style={{ display: 'flex', gap: 10, flexWrap: 'wrap', marginBottom: 10 }}>
                      <button onClick={exportSave} style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: '#10b981', color: 'white', fontWeight: 800 }}>
                        Export Save JSON
                      </button>
                      <button onClick={() => copyToClipboard(exportText || buildSaveExport())} style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: 'rgba(107,114,128,0.35)', color: 'white', fontWeight: 700 }}>
                        Copy Export JSON
                      </button>
                    </div>

                    {exportText && (
                      <textarea
                        value={exportText}
                        readOnly
                        style={{ width: '100%', minHeight: 160, padding: 12, borderRadius: 12, border: '1px solid rgba(255,255,255,0.12)', background: 'rgba(0,0,0,0.35)', color: '#e5e7eb', fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace', fontSize: 12 }}
                      />
                    )}

                    <div style={{ height: 12 }} />

                    <div style={{ display: 'grid', gap: 8 }}>
                      <div style={{ color: '#9ca3af', fontSize: 12 }}>Import save JSON (paste or choose a file):</div>
                      <input type="file" accept="application/json" onChange={(e) => handleImportFile(e.target.files && e.target.files[0])} style={{ color: '#e5e7eb' }} />
                      <textarea
                        value={importText}
                        onChange={(e) => setImportText(e.target.value)}
                        placeholder="Paste save JSON here…"
                        style={{ width: '100%', minHeight: 140, padding: 12, borderRadius: 12, border: '1px solid rgba(255,255,255,0.12)', background: 'rgba(0,0,0,0.35)', color: '#e5e7eb', fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace', fontSize: 12 }}
                      />
                      <div style={{ display: 'flex', gap: 10, flexWrap: 'wrap' }}>
                        <button
                          onClick={() => applyImportedSave(importText)}
                          style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: '#9333ea', color: 'white', fontWeight: 800 }}
                        >
                          Import & Reload
                        </button>
                        <button
                          onClick={() => setImportText('')}
                          style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: 'rgba(107,114,128,0.35)', color: 'white', fontWeight: 700 }}
                        >
                          Clear
                        </button>
                      </div>
                    </div>
                  </div>

                  <div style={{ padding: 16, borderRadius: 14, background: 'rgba(17,24,39,0.6)', border: '1px solid rgba(255,255,255,0.08)' }}>
                    <h3 style={{ margin: 0, marginBottom: 12, fontSize: 18 }}>Milestones</h3>
                    <div style={{ color: '#9ca3af', fontSize: 12, marginBottom: 12 }}>
                      Major moments are logged here so you can review them later (even if you accidentally click away).
                    </div>
                    {eventLog.length === 0 ? (
                      <div style={{ color: '#e5e7eb', opacity: 0.8 }}>No milestones yet.</div>
                    ) : (
                      <div style={{ display: 'grid', gap: 10 }}>
                        {eventLog.slice(0, 20).map((evt) => (
                          <div
                            key={evt.id}
                            onClick={() => openEventDetails(evt)}
                            style={{
                              cursor: 'pointer',
                              padding: 12,
                              borderRadius: 12,
                              border: '1px solid rgba(255,255,255,0.10)',
                              background: 'rgba(0,0,0,0.25)'
                            }}
                          >
                            <div style={{ display: 'flex', justifyContent: 'space-between', gap: 12 }}>
                              <div style={{ fontWeight: 800, color: '#e5e7eb' }}>{getEventLabel(evt)}</div>
                              <div style={{ color: '#9ca3af', fontSize: 12 }}>{evt.day ? `Day ${evt.day}` : ''}</div>
                            </div>
                            <div style={{ marginTop: 6, color: 'rgba(255,255,255,0.82)', fontSize: 13 }}>
                              {formatEventSummary(evt)}
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>

                  <div style={{ padding: 16, borderRadius: 14, background: 'rgba(17,24,39,0.6)', border: '1px solid rgba(255,255,255,0.08)' }}>
                    <h3 style={{ margin: 0, marginBottom: 12, fontSize: 18 }}>Danger Zone</h3>
                    <div style={{ display: 'flex', gap: 10, flexWrap: 'wrap' }}>
                      <button
                        onClick={resetAllSaveData}
                        style={{ padding: '10px 14px', borderRadius: 12, border: 'none', cursor: 'pointer', background: 'rgba(239,68,68,0.22)', color: '#fecaca', fontWeight: 800 }}
                      >
                        Reset All Progress
                      </button>
                    </div>
                    <div style={{ marginTop: 10, color: '#9ca3af', fontSize: 12 }}>
                      This clears all <code style={{ background: 'rgba(0,0,0,0.35)', padding: '2px 6px', borderRadius: 8 }}>tcg-*</code> keys from localStorage.
                    </div>
                  </div>
                </div>
              </div>
            )}

          </main>

          {/* Enlarged Card Modal */}
          {enlargedCard && (
            <div 
              onClick={() => setEnlargedCard(null)}
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0, 0, 0, 0.9)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 1000,
                cursor: 'zoom-out',
                padding: 32
              }}
            >
              <div style={{ display: 'flex', gap: 24, alignItems: 'center', maxWidth: '95vw' }} onClick={(e) => e.stopPropagation()}>
                {/* Card Image */}
                <div style={{ position: 'relative' }}>
                  <img 
                    src={enlargedCard.image} 
                    alt={enlargedCard.name}
                    style={{
                      maxWidth: '500px',
                      maxHeight: '80vh',
                      objectFit: 'contain',
                      borderRadius: 16,
                      border: `4px solid ${(RARITY_COLORS[enlargedCard.rarity] || { border: '#6b7280' }).border}`,
                      boxShadow: `0 0 40px ${(RARITY_COLORS[enlargedCard.rarity] || { border: '#6b7280' }).border}`,
                      cursor: 'default'
                    }}
                  />
                </div>
                
                {/* Price Info Panel */}
                {(() => {
                  const enlargedColors = RARITY_COLORS[enlargedCard.rarity] || { bg: '#374151', border: '#6b7280', text: '#d1d5db' };
                  return (
                <div style={{
                  background: 'rgba(0,0,0,0.8)',
                  padding: 24,
                  borderRadius: 16,
                  border: `2px solid ${enlargedColors.border}`,
                  minWidth: 300,
                  maxWidth: 400
                }}>
                  <h2 style={{ color: 'white', fontSize: 24, fontWeight: 'bold', margin: '0 0 8px' }}>{enlargedCard.name}</h2>
                  <p style={{ color: enlargedColors.text, fontSize: 16, textTransform: 'capitalize', margin: '0 0 24px' }}>
                    {enlargedCard.rarity}
                  </p>
                  {/* Market Values */}
                  {(() => {
                    const baseValue = (enlargedCard.marketValue || marketValues[enlargedCard.id] || 1);
                    const holoMult = getHoloMultiplier(enlargedCard.id);
                    const holoValue = baseValue * holoMult;
            const normalPayout = baseValue * SELL_TO_SHOP_RATE;
            const holoPayout = holoValue * SELL_TO_SHOP_RATE;
                    const isHolo = !!enlargedCard.isHolo;

                    const ownedEntry = collection[enlargedCard.id] || { normal: 0, holo: 0 };
                    const ownedHolo = (typeof enlargedCard.ownedHolo === 'number') ? enlargedCard.ownedHolo : (ownedEntry.holo || 0);
                    const showHoloRow = (view !== 'collection') || ownedHolo > 0 || isHolo;

                    return (
                      <div style={{ marginBottom: 24 }}>
                        <p style={{ color: '#9ca3af', fontSize: 14, margin: '0 0 10px' }}>Market Value</p>

                        <div style={{ display: 'grid', gap: 10 }}>
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', background: 'rgba(255,255,255,0.04)', border: '1px solid rgba(255,255,255,0.08)', borderRadius: 12, padding: 12 }}>
                            <div style={{ color: '#e5e7eb', fontSize: 13 }}>Non-Holo</div>
                            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                              <img src="./rations.png" alt="" style={{ width: 22, height: 22 }} />
                              <span style={{ color: '#fbbf24', fontSize: 22, fontWeight: 'bold' }}>{baseValue.toFixed(2)}</span>
                            </div>
                          </div>

                          {showHoloRow && (
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', background: 'rgba(255,255,255,0.04)', border: '1px solid rgba(255,255,255,0.08)', borderRadius: 12, padding: 12 }}>
                              <div style={{ color: '#e5e7eb', fontSize: 13 }}>
                                Holo <span style={{ color: '#9ca3af', fontSize: 12 }}>({holoMult.toFixed(2)}×)</span>
                              </div>
                              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                                <img src="./rations.png" alt="" style={{ width: 22, height: 22 }} />
                                <span className="rainbow-text" style={{ fontSize: 22, fontWeight: 'bold' }}>{holoValue.toFixed(2)}</span>
                              </div>
                            </div>
                          )}
                        </div>

                        {isHolo && (
                          <div style={{ marginTop: 10, fontSize: 12, color: '#d1d5db' }}>
                            <span className="holo-badge" style={{ padding: '3px 8px', borderRadius: 999, marginRight: 8 }}>HOLO</span>
                            This copy sells at the holo price.
                          </div>
                        )}

                        {enlargedCard.priceChange !== 0 && enlargedCard.priceChange !== undefined && (
                          <p style={{ 
                            color: enlargedCard.priceChange > 0 ? '#10b981' : '#ef4444', 
                            fontSize: 14, 
                            fontWeight: 'bold',
                            margin: '10px 0 0' 
                          }}>
                            {enlargedCard.priceChange > 0 ? '↑' : '↓'} {Math.abs(enlargedCard.priceChange).toFixed(2)}% vs yesterday
                          </p>
                        )}
                      </div>
                    );
                  })()}

{/* Price History Graph */}
                  {priceHistory[enlargedCard.id] && priceHistory[enlargedCard.id].length > 1 && (
                    <div>
                      <p style={{ color: '#9ca3af', fontSize: 14, margin: '0 0 12px' }}>
                        Price History (Last {Math.min(priceHistory[enlargedCard.id].length, 30)} Days)
                      </p>
                      <div style={{ background: '#1f2937', borderRadius: 8, padding: 16, height: 150, position: 'relative' }}>
                        <svg width="100%" height="100%" viewBox="0 0 300 120" preserveAspectRatio="none">
                          {(() => {
                            const history = priceHistory[enlargedCard.id].slice(-30);
                            const values = history.map(h => h.value);
                            const min = Math.min(...values) * 0.95;
                            const max = Math.max(...values) * 1.05;
                            const range = max - min;
                            
                            const points = history.map((h, i) => {
                              const x = (i / (history.length - 1)) * 300;
                              const y = 120 - ((h.value - min) / range) * 120;
                              return `${x},${y}`;
                            }).join(' ');
                            
                            return (
                              <>
                                <polyline
                                  points={points}
                                  fill="none"
                                  stroke="#10b981"
                                  strokeWidth="2"
                                />
                                {history.map((h, i) => {
                                  const x = (i / (history.length - 1)) * 300;
                                  const y = 120 - ((h.value - min) / range) * 120;
                                  return (
                                    <circle
                                      key={i}
                                      cx={x}
                                      cy={y}
                                      r="3"
                                      fill="#10b981"
                                    />
                                  );
                                })}
                              </>
                            );
                          })()}
                        </svg>
                      </div>
                      <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: 8 }}>
                        <span style={{ color: '#6b7280', fontSize: 12 }}>
                          {priceHistory[enlargedCard.id][0]?.value.toFixed(2)}R
                        </span>
                        <span style={{ color: '#6b7280', fontSize: 12 }}>
                          {priceHistory[enlargedCard.id][priceHistory[enlargedCard.id].length - 1]?.value.toFixed(2)}R
                        </span>
                      </div>
                    </div>
                  )}
                  
                  

                  {/* Discard (delete) from collection */}
                  {view === 'collection' && (() => {
                    const ownedEntry = collection[enlargedCard.id] || { normal: 0, holo: 0 };
                    const ownedNormal = (typeof enlargedCard.ownedNormal === 'number') ? enlargedCard.ownedNormal : (ownedEntry.normal || 0);
                    const ownedHolo = (typeof enlargedCard.ownedHolo === 'number') ? enlargedCard.ownedHolo : (ownedEntry.holo || 0);

                    if (ownedNormal === 0 && ownedHolo === 0) return null;

                    return (
                      <div style={{ marginTop: 12, display: 'grid', gap: 10 }}>
                        {ownedNormal > 0 && (
                          <button
                            onClick={() => discardFromCollection(enlargedCard.id, 'normal')}
                            style={{
                              width: '100%',
                              padding: '12px',
                              background: 'rgba(239,68,68,0.18)',
                              color: 'white',
                              border: '1px solid rgba(239,68,68,0.35)',
                              borderRadius: 8,
                              cursor: 'pointer',
                              fontSize: 14,
                              fontWeight: 'bold'
                            }}
                            title="Discard a non-holo copy (no rations gained)"
                          >
                            Discard Non-Holo
                          </button>
                        )}
                        {ownedHolo > 0 && (
                          <button
                            onClick={() => discardFromCollection(enlargedCard.id, 'holo')}
                            className="holo-button"
                            style={{
                              width: '100%',
                              padding: '12px',
                              borderRadius: 8,
                              cursor: 'pointer',
                              fontSize: 14,
                              fontWeight: 'bold',
                              border: 'none'
                            }}
                            title="Discard a holo copy (no rations gained)"
                          >
                            Discard Holo
                          </button>
                        )}
                        <div style={{ color: '#9ca3af', fontSize: 12, lineHeight: 1.3 }}>
                          Discarding permanently removes the card from your collection and gives <b>no</b> rations.
                        </div>
                      </div>
                    );
                  })()}

<button
                    onClick={() => setEnlargedCard(null)}
                    style={{
                      width: '100%',
                      padding: '12px',
                      marginTop: 24,
                      background: '#374151',
                      color: 'white',
                      border: 'none',
                      borderRadius: 8,
                      cursor: 'pointer',
                      fontSize: 14,
                      fontWeight: 'bold'
                    }}
                  >
                    Close
                  </button>
                </div>
                  );
                })()}
              </div>
            </div>
          )}
          
          
          
          

          {/* Purchase Confirmation Modal */}
          {purchaseConfirm && (
            <div
              onClick={() => setPurchaseConfirm(null)}
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0, 0, 0, 0.85)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 1100,
                padding: 32
              }}
            >
              <div
                onClick={(e) => e.stopPropagation()}
                style={{
                  background: '#111827',
                  border: '1px solid #374151',
                  borderRadius: 16,
                  padding: 24,
                  maxWidth: 420,
                  width: '100%'
                }}
              >
                <h2 style={{ fontSize: 18, margin: '0 0 10px', textAlign: 'center' }}>
                  Confirm Purchase
                </h2>

                <div style={{
                  background: 'rgba(255,255,255,0.04)',
                  border: '1px solid rgba(255,255,255,0.08)',
                  borderRadius: 12,
                  padding: 14,
                  marginBottom: 14
                }}>
                  <div style={{ fontWeight: 'bold', marginBottom: 6 }}>
                    {purchaseConfirm.title}
                  </div>
                  {purchaseConfirm.details && (
                    <div style={{ color: '#9ca3af', fontSize: 12, lineHeight: 1.4 }}>
                      {purchaseConfirm.details}
                    </div>
                  )}
                </div>

                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  marginBottom: 8
                }}>
                  <div style={{ color: '#9ca3af', fontSize: 12 }}>Cost</div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontWeight: 'bold' }}><img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />{(Number.isFinite(purchaseConfirm.cost) ? purchaseConfirm.cost.toFixed(2) : '—')}</div>
                </div>

                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  marginBottom: 18
                }}>
                  <div style={{ color: '#9ca3af', fontSize: 12 }}>Your balance</div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontWeight: 'bold' }}><img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />{rations.toFixed(2)}</div>
                </div>

                <div style={{ display: 'flex', gap: 12 }}>
                  <button
                    onClick={() => setPurchaseConfirm(null)}
                    style={{
                      flex: 1,
                      padding: '12px',
                      background: '#374151',
                      color: 'white',
                      border: 'none',
                      borderRadius: 8,
                      cursor: 'pointer',
                      fontSize: 14,
                      fontWeight: 'bold'
                    }}
                  >
                    Cancel
                  </button>

                  <button
                    onClick={confirmPurchase}
                    disabled={(!Number.isFinite(purchaseConfirm.cost) || rations < purchaseConfirm.cost)}
                    style={{
                      flex: 1,
                      padding: '12px',
                      background: (!Number.isFinite(purchaseConfirm.cost) || rations < purchaseConfirm.cost) ? '#1f2937' : 'linear-gradient(90deg, #3b82f6, #6366f1)',
                      color: (!Number.isFinite(purchaseConfirm.cost) || rations < purchaseConfirm.cost) ? '#6b7280' : 'white',
                      border: (!Number.isFinite(purchaseConfirm.cost) || rations < purchaseConfirm.cost) ? '1px solid rgba(255,255,255,0.10)' : 'none',
                      borderRadius: 8,
                      cursor: (!Number.isFinite(purchaseConfirm.cost) || rations < purchaseConfirm.cost) ? 'not-allowed' : 'pointer',
                      fontSize: 14,
                      fontWeight: 'bold'
                    }}
                  >
                    Confirm Purchase
                  </button>
                </div>
              </div>
            </div>
          )}
{/* Sell Confirmation Modal */}
          {sellConfirm && (() => {
            const entry = collection[sellConfirm.id] || { normal: 0, holo: 0 };
            const baseValue = getBaseMarketValue(sellConfirm.id);
            const holoMult = getHoloMultiplier(sellConfirm.id);
            const holoValue = baseValue * holoMult;
            const normalPayout = baseValue * SELL_TO_SHOP_RATE;
            const holoPayout = holoValue * SELL_TO_SHOP_RATE;
            const hasNormal = (entry.normal || 0) > 0;
            const hasHolo = (entry.holo || 0) > 0;

            return (
              <div
                onClick={() => setSellConfirm(null)}
                style={{
                  position: 'fixed',
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  background: 'rgba(0, 0, 0, 0.85)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  zIndex: 1100,
                  padding: 32
                }}
              >
                <div
                  onClick={(e) => e.stopPropagation()}
                  style={{
                    background: '#111827',
                    border: '1px solid #374151',
                    borderRadius: 16,
                    padding: 24,
                    maxWidth: 420,
                    width: '100%'
                  }}
                >
                  <h2 style={{ fontSize: 18, margin: '0 0 8px', textAlign: 'center' }}>
                    Sell Card
                  </h2>

                  <div style={{ margin: '0 0 14px', textAlign: 'center' }}>
                    <div style={{ fontWeight: 'bold', marginBottom: 4 }}>{sellConfirm.name}</div>
                    <div
                      style={{
                        display: 'inline-block',
                        padding: '4px 10px',
                        borderRadius: 999,
                        background: 'rgba(255, 255, 255, 0.07)',
                        border: '1px solid rgba(255, 255, 255, 0.12)',
                        color: RARITY_COLORS[sellConfirm.rarity] || '#9ca3af',
                        fontSize: 12,
                        textTransform: 'uppercase',
                        letterSpacing: '0.08em'
                      }}
                    >
                      {sellConfirm.rarity}
                    </div>
                  </div>

                  <div style={{ display: 'flex', justifyContent: 'center', gap: 10, marginBottom: 16, flexWrap: 'wrap' }}>
                    {(entry.normal || 0) > 0 && (
                      <span style={{
                        padding: '6px 10px',
                        background: 'rgba(255,255,255,0.06)',
                        border: '1px solid rgba(255,255,255,0.12)',
                        borderRadius: 10,
                        fontSize: 12,
                        color: '#e5e7eb'
                      }}>
                        Normal: x{entry.normal || 0}
                      </span>
                    )}
                    {(entry.holo || 0) > 0 && (
                      <span className="holo-badge" style={{
                        padding: '6px 10px',
                        borderRadius: 10,
                        fontSize: 12,
                        fontWeight: 'bold'
                      }}>
                        Holo: x{entry.holo || 0}
                      </span>
                    )}
                    {(entry.normal || 0) === 0 && (entry.holo || 0) === 0 && (
                      <span style={{ color: '#9ca3af', fontSize: 12 }}>You don’t own this card</span>
                    )}
                  </div>

                  <div style={{ display: 'grid', gap: 10, marginBottom: 18 }}>
                    <div style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      background: 'rgba(255,255,255,0.04)',
                      border: '1px solid rgba(255,255,255,0.08)',
                      borderRadius: 12,
                      padding: 12
                    }}>
                      <div style={{ color: '#9ca3af', fontSize: 12 }}>Normal shop payout (60%)</div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontWeight: 'bold' }}><img src="./rations.png" alt="" style={{ width: 16, height: 16 }} />{normalPayout.toFixed(2)}</div>
                    </div>
                    <div style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      background: 'rgba(255,255,255,0.04)',
                      border: '1px solid rgba(255,255,255,0.08)',
                      borderRadius: 12,
                      padding: 12
                    }}>
                      <div style={{ color: '#9ca3af', fontSize: 12 }}>Holo shop payout (60%) <span style={{ opacity: 0.8 }}>({holoMult.toFixed(2)}×)</span></div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontWeight: 'bold' }}><img src="./rations.png" alt="" style={{ width: 16, height: 16 }} /><span className="rainbow-text">{holoPayout.toFixed(2)}</span></div>
                    </div>
                  </div>

                  <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                    <button
                      onClick={() => setSellConfirm(null)}
                      style={{
                        flex: 1,
                        minWidth: 110,
                        padding: '12px',
                        background: '#374151',
                        color: 'white',
                        border: 'none',
                        borderRadius: 8,
                        cursor: 'pointer',
                        fontSize: 14,
                        fontWeight: 'bold'
                      }}
                    >
                      Cancel
                    </button>

                    <button
                      onClick={() => sellNormalCard(sellConfirm.id)}
                      disabled={!hasNormal}
                      style={{
                        flex: 1,
                        minWidth: 140,
                        padding: '12px',
                        background: hasNormal ? 'linear-gradient(90deg, #10b981, #059669)' : '#1f2937',
                        color: hasNormal ? 'white' : '#6b7280',
                        border: hasNormal ? 'none' : '1px solid rgba(255,255,255,0.10)',
                        borderRadius: 8,
                        cursor: hasNormal ? 'pointer' : 'not-allowed',
                        fontSize: 14,
                        fontWeight: 'bold'
                      }}
                    >
                      Sell Normal
                    </button>

                    {hasHolo && (
                      <button
                        onClick={() => sellHoloCard(sellConfirm.id)}
                        className="holo-button"
                        style={{
                          flex: 1,
                          minWidth: 140,
                          padding: '12px',
                          borderRadius: 8,
                          cursor: 'pointer',
                          fontSize: 14,
                          fontWeight: 'bold',
                          color: 'white',
                          border: 'none'
                        }}
                      >
                        Sell Holo
                      </button>
                    )}
                  </div>
                </div>
              </div>
            );
          })()}</div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
