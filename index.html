<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCG Pack Opener</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --slot-color: rgba(255, 255, 255, 0.1);
            --card-width: 140px;
            --card-height: 196px;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Prevent scrolling while dragging */
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            perspective: 1000px; /* Essential for 3D effects */
        }

        /* UI Elements */
        #ui-layer {
            position: absolute;
            top: 20px;
            color: white;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
        
        button {
            pointer-events: auto;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #fff;
            border: none;
            border-radius: 4px;
            margin-top: 10px;
            display: none; /* Hidden until pack is opened */
        }

        /* PLAY AREA */
        #play-area {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* SLOTS GRID */
        #slots-container {
            display: grid;
            grid-template-columns: repeat(4, var(--card-width));
            grid-gap: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
        }

        .slot {
            width: var(--card-width);
            height: var(--card-height);
            background: var(--slot-color);
            border-radius: 10px;
            border: 2px dashed rgba(255,255,255,0.2);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        /* THE PACK */
        #pack-container {
            position: absolute;
            z-index: 50;
            width: 200px;
            height: 280px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.5s ease, opacity 0.5s ease;
        }

        .pack-body {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff0000, #990000);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 24px;
            position: relative;
            overflow: hidden;
        }

        .tear-strip {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: repeating-linear-gradient(
                45deg,
                #ffd700,
                #ffd700 10px,
                #ffcc00 10px,
                #ffcc00 20px
            );
            border-bottom: 2px dashed #000;
            cursor: col-resize; /* Suggests dragging */
            z-index: 51;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 10px;
            box-sizing: border-box;
            transition: width 0.1s linear;
        }

        .tear-strip::after {
            content: "DRAG >>";
            font-size: 12px;
            color: black;
            font-weight: bold;
            margin-left: 5px;
        }

        /* CARDS */
        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            /* Start cards in the center (inside pack) */
            top: 50%; 
            left: 50%;
            margin-top: calc(var(--card-height) / -2);
            margin-left: calc(var(--card-width) / -2);
            z-index: 10;
            cursor: grab;
            user-select: none;
            touch-action: none;
        }

        .card-wrapper:active {
            cursor: grabbing;
            z-index: 100; /* Pop to top when held */
        }

        .card-visual {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            transition: transform 0.1s ease-out; /* Smooth tilt return */
            transform-style: preserve-3d;
            background-size: cover;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            border: 4px solid white;
            box-sizing: border-box;
        }

        /* Rarity Styles */
        .common { background-color: #7f8c8d; } /* Gray */
        .uncommon { background-color: #27ae60; } /* Green */
        .rare { background-color: #2980b9; } /* Blue */
        .legendary { background-color: #8e44ad; } /* Purple */
        .ultra { background-color: #d35400; } /* Orange */

        /* Foil Effect */
        .foil-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 6px; /* slightly less than card */
            background: linear-gradient(
                115deg, 
                transparent 20%, 
                rgba(255, 255, 255, 0.4) 40%, 
                rgba(255, 255, 255, 0.6) 50%, 
                rgba(255, 255, 255, 0.4) 60%, 
                transparent 80%
            );
            opacity: 0;
            pointer-events: none;
            mix-blend-mode: overlay;
            transition: opacity 0.2s;
            background-size: 200% 200%;
        }

        .card-wrapper.is-foil .foil-overlay {
            opacity: 1;
        }

        /* Floating Animation (Idle) */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        .card-wrapper.idle .card-visual {
            animation: float 3s ease-in-out infinite;
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>TCG Pack Opener</h1>
        <p>Drag the yellow strip to rip the pack!</p>
        <button onclick="reset()">Open New Pack</button>
    </div>

    <div id="play-area">
        
        <div id="slots-container">
            </div>

        <div id="pack-container">
            <div class="pack-body">
                GENERIC TCG
            </div>
            <div class="tear-strip" id="tear-strip"></div>
        </div>

        <div id="card-layer"></div>

    </div>

<script>
    // --- CONFIGURATION ---
    const CARD_WIDTH = 140;
    const CARD_HEIGHT = 196;
    const TOTAL_CARDS = 8;
    
    // Rarity Definitions
    const RARITY = {
        COMMON: { name: 'Common', class: 'common' },
        UNCOMMON: { name: 'Uncommon', class: 'uncommon' },
        RARE: { name: 'Rare', class: 'rare' },
        LEGENDARY: { name: 'Legendary', class: 'legendary' },
        ULTRA: { name: 'Ultra Rare', class: 'ultra' }
    };

    // --- STATE ---
    let cards = [];
    let slots = [];
    let isPackOpen = false;

    // --- INITIALIZATION ---
    function init() {
        createSlots();
        setupPackInteraction();
    }

    function createSlots() {
        const container = document.getElementById('slots-container');
        container.innerHTML = '';
        slots = []; // reset state
        
        for(let i=0; i<TOTAL_CARDS; i++) {
            const slot = document.createElement('div');
            slot.classList.add('slot');
            slot.id = `slot-${i}`;
            container.appendChild(slot);
            slots.push(slot);
        }
    }

    // --- PACK LOGIC ---
    
    // Weighted Random Helper
    function getWeightedRarity(table) {
        const rand = Math.random() * 100;
        let sum = 0;
        for (const item of table) {
            sum += item.chance;
            if (rand < sum) return item.type;
        }
        return table[0].type; // Fallback
    }

    function generatePackContents() {
        let packCards = [];

        // 1. Add 4 Commons
        for(let i=0; i<4; i++) packCards.push({ rarity: RARITY.COMMON, foil: false });

        // 2. Add 2 Uncommons
        for(let i=0; i<2; i++) packCards.push({ rarity: RARITY.UNCOMMON, foil: false });

        // 3. Rare Slot (89% Rare, 10% Legendary, 1% Ultra)
        const rareTable = [
            { chance: 89, type: RARITY.RARE },
            { chance: 10, type: RARITY.LEGENDARY },
            { chance: 1, type: RARITY.ULTRA }
        ];
        packCards.push({ rarity: getWeightedRarity(rareTable), foil: false });

        // 4. Foil Slot
        const foilTable = [
            { chance: 47, type: RARITY.COMMON },
            { chance: 34, type: RARITY.UNCOMMON },
            { chance: 13, type: RARITY.RARE },
            { chance: 5, type: RARITY.LEGENDARY },
            { chance: 1, type: RARITY.ULTRA }
        ];
        packCards.push({ rarity: getWeightedRarity(foilTable), foil: true });

        return packCards;
    }

    // --- INTERACTION LOGIC ---

    function setupPackInteraction() {
        const strip = document.getElementById('tear-strip');
        const pack = document.getElementById('pack-container');
        let startX = 0;
        let isTearing = false;

        strip.onmousedown = (e) => {
            isTearing = true;
            startX = e.clientX;
            strip.style.cursor = 'grabbing';
        };

        window.onmouseup = () => {
            if(isTearing) {
                isTearing = false;
                strip.style.cursor = 'col-resize';
                // Reset if not fully torn
                if(!isPackOpen) strip.style.width = '100%'; 
            }
        };

        window.onmousemove = (e) => {
            if(!isTearing || isPackOpen) return;

            const currentX = e.clientX;
            const diff = currentX - startX;
            const packWidth = pack.offsetWidth;

            // Visual feedback of tearing (shrinking the strip)
            // We want it to look like it's being ripped from left to right
            if (diff > 0) {
                // Calculate percentage torn
                const percentage = Math.min(100, (diff / packWidth) * 100);
                
                // If torn past 80%, open pack
                if (percentage > 80) {
                    openPack();
                }
            }
        };
    }

    function openPack() {
        if(isPackOpen) return;
        isPackOpen = true;

        const pack = document.getElementById('pack-container');
        
        // Animation: Hide pack, spawn cards
        pack.style.transform = "scale(1.2)";
        pack.style.opacity = "0";
        
        setTimeout(() => {
            pack.style.display = 'none';
            spawnCards();
            document.querySelector('button').style.display = 'inline-block';
        }, 500);
    }

    function spawnCards() {
        const contents = generatePackContents();
        const layer = document.getElementById('card-layer');

        contents.forEach((data, index) => {
            // Create DOM elements
            const wrapper = document.createElement('div');
            wrapper.classList.add('card-wrapper', 'idle');
            if(data.foil) wrapper.classList.add('is-foil');

            const visual = document.createElement('div');
            visual.classList.add('card-visual', data.rarity.class);
            visual.innerText = data.rarity.name;

            const foil = document.createElement('div');
            foil.classList.add('foil-overlay');

            visual.appendChild(foil);
            wrapper.appendChild(visual);
            layer.appendChild(wrapper);

            // Add Physics Handlers
            addCardPhysics(wrapper, visual);

            // Animate out from center (Explosion effect)
            // Slight delay based on index for satisfying pop
            setTimeout(() => {
                // Spread them out roughly
                // Use a little randomness so they don't look robotic
                const randomX = (Math.random() - 0.5) * 400;
                const randomY = (Math.random() - 0.5) * 400;
                
                wrapper.style.transition = "top 0.5s ease, left 0.5s ease";
                wrapper.style.left = `calc(50% + ${randomX}px)`;
                wrapper.style.top = `calc(50% + ${randomY}px)`;

                // Remove transition after move so dragging is instant
                setTimeout(() => {
                    wrapper.style.transition = "";
                }, 500);
            }, index * 100);

            cards.push({ element: wrapper, data: data });
        });
    }

    // --- CARD PHYSICS & DRAGGING ---

    function addCardPhysics(wrapper, visual) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;

        // 1. TILT EFFECT (Hover)
        wrapper.addEventListener('mousemove', (e) => {
            if (isDragging) return;

            const rect = wrapper.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Calculate rotation (center is 0,0)
            // Max rotation +/- 20deg
            const xPct = (x / rect.width) - 0.5;
            const yPct = (y / rect.height) - 0.5;

            const rotateY = xPct * 40; // Tilt left/right
            const rotateX = -yPct * 40; // Tilt up/down

            visual.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.1)`;
            
            // Foil Shimmer Movement
            // We move the background position of the gradient
            if(wrapper.classList.contains('is-foil')) {
                const foil = visual.querySelector('.foil-overlay');
                foil.style.backgroundPosition = `${50 + (xPct * 100)}% ${50 + (yPct * 100)}%`;
            }
        });

        wrapper.addEventListener('mouseleave', () => {
            if (isDragging) return;
            visual.style.transform = `rotateX(0) rotateY(0) scale(1)`;
        });

        // 2. DRAG LOGIC
        wrapper.addEventListener('mousedown', (e) => {
            isDragging = true;
            wrapper.classList.remove('idle'); // Stop floating
            visual.style.transform = `scale(1.05)`; // Small lift
            wrapper.style.zIndex = 1000; // Bring to front

            startX = e.clientX;
            startY = e.clientY;

            // Get current CSS positions (handling "auto" or "calc")
            const rect = wrapper.getBoundingClientRect();
            // We need to set explicit pixel values to drag properly
            // Convert rect to absolute position relative to parent
            const parentRect = wrapper.parentElement.getBoundingClientRect();
            
            // Set initial inline styles if not present (converting calc to px)
            wrapper.style.left = (rect.left - parentRect.left) + 'px';
            wrapper.style.top = (rect.top - parentRect.top) + 'px';
            
            initialLeft = parseFloat(wrapper.style.left);
            initialTop = parseFloat(wrapper.style.top);

            e.preventDefault();
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            wrapper.style.left = `${initialLeft + dx}px`;
            wrapper.style.top = `${initialTop + dy}px`;
            
            // Dynamic tilt based on drag velocity could go here for extra juice
        });

        window.addEventListener('mouseup', (e) => {
            if (!isDragging) return;
            isDragging = false;
            wrapper.style.zIndex = 10;
            visual.style.transform = `rotateX(0) rotateY(0) scale(1)`;

            // SNAP LOGIC
            snapToSlot(wrapper);
        });
    }

    function snapToSlot(cardWrapper) {
        const cardRect = cardWrapper.getBoundingClientRect();
        const cardCenterX = cardRect.left + cardRect.width / 2;
        const cardCenterY = cardRect.top + cardRect.height / 2;

        let closestSlot = null;
        let minDist = Infinity;

        // Find closest slot
        slots.forEach(slot => {
            const slotRect = slot.getBoundingClientRect();
            const slotCenterX = slotRect.left + slotRect.width / 2;
            const slotCenterY = slotRect.top + slotRect.height / 2;

            const dist = Math.hypot(cardCenterX - slotCenterX, cardCenterY - slotCenterY);
            
            if (dist < minDist) {
                minDist = dist;
                closestSlot = slot;
            }
        });

        // Threshold for snapping (e.g., 100px)
        if (closestSlot && minDist < 100) {
            // Snap to the center of the slot
            // We calculate the position relative to the play-area
            const parentRect = document.getElementById('card-layer').getBoundingClientRect();
            const slotRect = closestSlot.getBoundingClientRect();

            // Calculate target Left/Top relative to parent
            const targetLeft = slotRect.left - parentRect.left;
            const targetTop = slotRect.top - parentRect.top;

            // Apply transition for smooth snap
            cardWrapper.style.transition = "top 0.2s ease-out, left 0.2s ease-out";
            cardWrapper.style.left = `${targetLeft}px`;
            cardWrapper.style.top = `${targetTop}px`;

            // Remove transition after snap
            setTimeout(() => {
                cardWrapper.style.transition = "";
            }, 200);
        }
    }

    function reset() {
        document.getElementById('card-layer').innerHTML = '';
        cards = [];
        isPackOpen = false;
        
        const pack = document.getElementById('pack-container');
        pack.style.display = 'block';
        pack.style.opacity = '1';
        pack.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // Reset tear strip
        document.getElementById('tear-strip').style.width = '100%';
        document.querySelector('button').style.display = 'none';
    }

    // Start
    init();

</script>
</body>
</html>
